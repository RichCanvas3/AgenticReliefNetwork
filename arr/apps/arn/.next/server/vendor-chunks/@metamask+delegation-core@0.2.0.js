"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask+delegation-core@0.2.0";
exports.ids = ["vendor-chunks/@metamask+delegation-core@0.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+delegation-core@0.2.0/node_modules/@metamask/delegation-core/dist/index.mjs":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+delegation-core@0.2.0/node_modules/@metamask/delegation-core/dist/index.mjs ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANY_BENEFICIARY: () => (/* binding */ ANY_BENEFICIARY),\n/* harmony export */   CAVEAT_TYPEHASH: () => (/* binding */ CAVEAT_TYPEHASH),\n/* harmony export */   DELEGATION_TYPEHASH: () => (/* binding */ DELEGATION_TYPEHASH),\n/* harmony export */   ROOT_AUTHORITY: () => (/* binding */ ROOT_AUTHORITY),\n/* harmony export */   createERC20StreamingTerms: () => (/* binding */ createERC20StreamingTerms),\n/* harmony export */   createERC20TokenPeriodTransferTerms: () => (/* binding */ createERC20TokenPeriodTransferTerms),\n/* harmony export */   createExactCalldataTerms: () => (/* binding */ createExactCalldataTerms),\n/* harmony export */   createNativeTokenPeriodTransferTerms: () => (/* binding */ createNativeTokenPeriodTransferTerms),\n/* harmony export */   createNativeTokenStreamingTerms: () => (/* binding */ createNativeTokenStreamingTerms),\n/* harmony export */   createNonceTerms: () => (/* binding */ createNonceTerms),\n/* harmony export */   createTimestampTerms: () => (/* binding */ createTimestampTerms),\n/* harmony export */   createValueLteTerms: () => (/* binding */ createValueLteTerms),\n/* harmony export */   decodeDelegations: () => (/* binding */ decodeDelegations),\n/* harmony export */   encodeDelegations: () => (/* binding */ encodeDelegations),\n/* harmony export */   hashDelegation: () => (/* binding */ hashDelegation)\n/* harmony export */ });\n/* harmony import */ var _metamask_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @metamask/utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.mjs\");\n/* harmony import */ var _metamask_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.mjs\");\n/* harmony import */ var _metamask_abi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/abi-utils */ \"(ssr)/../../node_modules/.pnpm/@metamask+abi-utils@3.0.0/node_modules/@metamask/abi-utils/dist/index.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js\");\n// src/returns.ts\n\nvar defaultOptions = { out: \"hex\" };\nfunction prepareResult(result, options) {\n  if (options.out === \"hex\") {\n    const hexValue = typeof result === \"string\" ? result : (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(result);\n    return hexValue.startsWith(\"0x\") ? hexValue : `0x${hexValue}`;\n  }\n  const bytesValue = result instanceof Uint8Array ? result : (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(result);\n  return bytesValue;\n}\nvar bytesLikeToHex = (bytesLike) => {\n  if (typeof bytesLike === \"string\") {\n    return bytesLike;\n  }\n  return (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytesLike);\n};\nvar bytesLikeToBytes = (bytesLike) => {\n  if (typeof bytesLike === \"string\") {\n    return (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(bytesLike);\n  }\n  return bytesLike;\n};\n\n// src/utils.ts\nvar toHexString = ({\n  value,\n  size\n}) => {\n  return value.toString(16).padStart(size * 2, \"0\");\n};\n\n// src/caveats/valueLte.ts\nfunction createValueLteTerms(terms, options = defaultOptions) {\n  const { maxValue } = terms;\n  if (maxValue < 0n) {\n    throw new Error(\"Invalid maxValue: must be greater than or equal to zero\");\n  }\n  const hexValue = toHexString({ value: maxValue, size: 32 });\n  return prepareResult(hexValue, options);\n}\n\n// src/caveats/timestamp.ts\nvar TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\nfunction createTimestampTerms(terms, encodingOptions = defaultOptions) {\n  const { timestampAfterThreshold, timestampBeforeThreshold } = terms;\n  if (timestampAfterThreshold < 0) {\n    throw new Error(\n      \"Invalid timestampAfterThreshold: must be zero or positive\"\n    );\n  }\n  if (timestampBeforeThreshold < 0) {\n    throw new Error(\n      \"Invalid timestampBeforeThreshold: must be zero or positive\"\n    );\n  }\n  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampBeforeThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`\n    );\n  }\n  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampAfterThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`\n    );\n  }\n  if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {\n    throw new Error(\n      \"Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified\"\n    );\n  }\n  const afterThresholdHex = toHexString({\n    value: timestampAfterThreshold,\n    size: 16\n  });\n  const beforeThresholdHex = toHexString({\n    value: timestampBeforeThreshold,\n    size: 16\n  });\n  const hexValue = `0x${afterThresholdHex}${beforeThresholdHex}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/caveats/nativeTokenPeriodTransfer.ts\nfunction createNativeTokenPeriodTransferTerms(terms, encodingOptions = defaultOptions) {\n  const { periodAmount, periodDuration, startDate } = terms;\n  if (periodAmount <= 0n) {\n    throw new Error(\"Invalid periodAmount: must be a positive number\");\n  }\n  if (periodDuration <= 0) {\n    throw new Error(\"Invalid periodDuration: must be a positive number\");\n  }\n  if (startDate <= 0) {\n    throw new Error(\"Invalid startDate: must be a positive number\");\n  }\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n  const hexValue = `0x${periodAmountHex}${periodDurationHex}${startDateHex}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/caveats/exactCalldata.ts\nfunction createExactCalldataTerms(terms, encodingOptions = defaultOptions) {\n  const { calldata } = terms;\n  if (typeof calldata === \"string\" && !calldata.startsWith(\"0x\")) {\n    throw new Error(\"Invalid calldata: must be a hex string starting with 0x\");\n  }\n  return prepareResult(calldata, encodingOptions);\n}\n\n// src/caveats/nativeTokenStreaming.ts\nvar TIMESTAMP_UPPER_BOUND_SECONDS2 = 253402300799;\nfunction createNativeTokenStreamingTerms(terms, encodingOptions = defaultOptions) {\n  const { initialAmount, maxAmount, amountPerSecond, startTime } = terms;\n  if (initialAmount < 0n) {\n    throw new Error(\"Invalid initialAmount: must be greater than zero\");\n  }\n  if (maxAmount <= 0n) {\n    throw new Error(\"Invalid maxAmount: must be a positive number\");\n  }\n  if (maxAmount < initialAmount) {\n    throw new Error(\"Invalid maxAmount: must be greater than initialAmount\");\n  }\n  if (amountPerSecond <= 0n) {\n    throw new Error(\"Invalid amountPerSecond: must be a positive number\");\n  }\n  if (startTime <= 0) {\n    throw new Error(\"Invalid startTime: must be a positive number\");\n  }\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS2) {\n    throw new Error(\n      \"Invalid startTime: must be less than or equal to 253402300799\"\n    );\n  }\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n  const hexValue = `0x${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/caveats/erc20Streaming.ts\n\nvar TIMESTAMP_UPPER_BOUND_SECONDS3 = 253402300799;\nfunction createERC20StreamingTerms(terms, encodingOptions = defaultOptions) {\n  const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } = terms;\n  if (!tokenAddress) {\n    throw new Error(\"Invalid tokenAddress: must be a valid address\");\n  }\n  let prefixedTokenAddressHex;\n  if (typeof tokenAddress === \"string\") {\n    if (!(0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isHexString)(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error(\"Invalid tokenAddress: must be a valid address\");\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error(\"Invalid tokenAddress: must be a valid address\");\n    }\n    prefixedTokenAddressHex = (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tokenAddress);\n  }\n  if (initialAmount < 0n) {\n    throw new Error(\"Invalid initialAmount: must be greater than zero\");\n  }\n  if (maxAmount <= 0n) {\n    throw new Error(\"Invalid maxAmount: must be a positive number\");\n  }\n  if (maxAmount < initialAmount) {\n    throw new Error(\"Invalid maxAmount: must be greater than initialAmount\");\n  }\n  if (amountPerSecond <= 0n) {\n    throw new Error(\"Invalid amountPerSecond: must be a positive number\");\n  }\n  if (startTime <= 0) {\n    throw new Error(\"Invalid startTime: must be a positive number\");\n  }\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS3) {\n    throw new Error(\n      \"Invalid startTime: must be less than or equal to 253402300799\"\n    );\n  }\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n  const hexValue = `${prefixedTokenAddressHex}${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/caveats/erc20TokenPeriodTransfer.ts\n\nfunction createERC20TokenPeriodTransferTerms(terms, encodingOptions = defaultOptions) {\n  const { tokenAddress, periodAmount, periodDuration, startDate } = terms;\n  if (!tokenAddress) {\n    throw new Error(\"Invalid tokenAddress: must be a valid address\");\n  }\n  let prefixedTokenAddressHex;\n  if (typeof tokenAddress === \"string\") {\n    if (!(0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isHexString)(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error(\"Invalid tokenAddress: must be a valid address\");\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error(\"Invalid tokenAddress: must be a valid address\");\n    }\n    prefixedTokenAddressHex = (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tokenAddress);\n  }\n  if (periodAmount <= 0n) {\n    throw new Error(\"Invalid periodAmount: must be a positive number\");\n  }\n  if (periodDuration <= 0) {\n    throw new Error(\"Invalid periodDuration: must be a positive number\");\n  }\n  if (startDate <= 0) {\n    throw new Error(\"Invalid startDate: must be a positive number\");\n  }\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n  const hexValue = `${prefixedTokenAddressHex}${periodAmountHex}${periodDurationHex}${startDateHex}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/caveats/nonce.ts\n\nvar MAX_NONCE_STRING_LENGTH = 66;\nfunction createNonceTerms(terms, encodingOptions = defaultOptions) {\n  const { nonce } = terms;\n  if (nonce instanceof Uint8Array && nonce.length === 0) {\n    throw new Error(\"Invalid nonce: Uint8Array must not be empty\");\n  }\n  if (typeof nonce === \"string\" && !nonce.startsWith(\"0x\")) {\n    throw new Error(\"Invalid nonce: string must have 0x prefix\");\n  }\n  const hexNonce = bytesLikeToHex(nonce);\n  if (hexNonce === \"0x\") {\n    throw new Error(\"Invalid nonce: must not be empty\");\n  }\n  if (!(0,_metamask_utils__WEBPACK_IMPORTED_MODULE_1__.isHexString)(hexNonce)) {\n    throw new Error(\"Invalid nonce: must be a valid BytesLike value\");\n  }\n  if (hexNonce.length > MAX_NONCE_STRING_LENGTH) {\n    throw new Error(\"Invalid nonce: must be 32 bytes or less in length\");\n  }\n  const nonceWithoutPrefix = hexNonce.slice(2);\n  const paddedNonce = nonceWithoutPrefix.padStart(64, \"0\");\n  const hexValue = `0x${paddedNonce}`;\n  return prepareResult(hexValue, encodingOptions);\n}\n\n// src/delegation.ts\n\n\n\nvar ANY_BENEFICIARY = \"0x0000000000000000000000000000000000000a11\";\nvar ROOT_AUTHORITY = \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\nvar DELEGATION_TYPEHASH = \"0x88c1d2ecf185adf710588203a5f263f0ff61be0d33da39792cde19ba9aa4331e\";\nvar CAVEAT_TYPEHASH = \"0x80ad7e1b04ee6d994a125f4714ca0720908bd80ed16063ec8aee4b88e9253e2d\";\nvar DELEGATION_ARRAY_ABI_TYPES = \"(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]\";\nfunction encodeDelegations(delegations, options = defaultOptions) {\n  let result;\n  if (delegations.length === 0) {\n    result = new Uint8Array(64);\n    result[31] = 32;\n  } else {\n    const encodableStructs = delegations.map((struct) => [\n      struct.delegate,\n      struct.delegator,\n      struct.authority,\n      struct.caveats.map((caveat) => [\n        caveat.enforcer,\n        caveat.terms,\n        caveat.args\n      ]),\n      struct.salt,\n      struct.signature\n    ]);\n    result = (0,_metamask_abi_utils__WEBPACK_IMPORTED_MODULE_2__.encodeSingle)(DELEGATION_ARRAY_ABI_TYPES, encodableStructs);\n  }\n  return prepareResult(result, options);\n}\nvar delegationFromDecodedDelegation = (decodedDelegation, convertFn) => {\n  const [delegate, delegator, authority, caveats, salt, signature] = decodedDelegation;\n  return {\n    delegate: convertFn(delegate),\n    delegator: convertFn(delegator),\n    authority: convertFn(authority),\n    caveats: caveats.map(([enforcer, terms, args]) => ({\n      enforcer: convertFn(enforcer),\n      terms: convertFn(terms),\n      args: convertFn(args)\n    })),\n    salt,\n    signature: convertFn(signature)\n  };\n};\nfunction decodeDelegations(encoded, options = defaultOptions) {\n  const decodedStructs = (0,_metamask_abi_utils__WEBPACK_IMPORTED_MODULE_2__.decodeSingle)(\n    DELEGATION_ARRAY_ABI_TYPES,\n    encoded\n    // return types cannot be inferred from complex ABI types, so we must assert the type\n  );\n  if (options.out === \"bytes\") {\n    return decodedStructs.map(\n      (struct) => delegationFromDecodedDelegation(struct, bytesLikeToBytes)\n    );\n  }\n  return decodedStructs.map(\n    (struct) => delegationFromDecodedDelegation(struct, bytesLikeToHex)\n  );\n}\nfunction hashDelegation(delegation, options = defaultOptions) {\n  const encoded = (0,_metamask_abi_utils__WEBPACK_IMPORTED_MODULE_2__.encode)(\n    [\"bytes32\", \"address\", \"address\", \"bytes32\", \"bytes32\", \"uint256\"],\n    [\n      DELEGATION_TYPEHASH,\n      delegation.delegate,\n      delegation.delegator,\n      delegation.authority,\n      getCaveatsArrayHash(delegation.caveats),\n      delegation.salt\n    ]\n  );\n  const hash = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.keccak_256)(encoded);\n  return prepareResult(hash, options);\n}\nfunction getCaveatsArrayHash(caveats) {\n  const byteLength = 32 * caveats.length;\n  const encoded = new Uint8Array(byteLength);\n  for (let i = 0; i < caveats.length; i++) {\n    const caveat = caveats[i];\n    if (!caveat) {\n      throw new Error(`Caveat was undefined at index ${i}`);\n    }\n    const caveatHash = getCaveatHash(caveat);\n    encoded.set(caveatHash, i * 32);\n  }\n  return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.keccak_256)(encoded);\n}\nfunction getCaveatHash(caveat) {\n  const termsBytes = typeof caveat.terms === \"string\" ? (0,_metamask_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(caveat.terms) : caveat.terms;\n  const termsHash = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.keccak_256)(termsBytes);\n  const encoded = (0,_metamask_abi_utils__WEBPACK_IMPORTED_MODULE_2__.encode)(\n    [\"bytes32\", \"address\", \"bytes32\"],\n    [CAVEAT_TYPEHASH, caveat.enforcer, termsHash]\n  );\n  const hash = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.keccak_256)(encoded);\n  return hash;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzaytkZWxlZ2F0aW9uLWNvcmVAMC4yLjAvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9kZWxlZ2F0aW9uLWNvcmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3lEO0FBQ3pELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkRBQTJELDJEQUFVO0FBQ3JFLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0EsNkRBQTZELDJEQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkRBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDhCQUE4QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLGtCQUFrQixFQUFFLG1CQUFtQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFLDBDQUEwQyxpQ0FBaUM7QUFDM0UscUNBQXFDLDRCQUE0QjtBQUNqRSx3QkFB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QjtBQUNBO0FBQ0Esd0RBQXdELDJEQUFXO0FBQ25FLG9CQUFvQiw4REFBUztBQUM3QixrQkFBa0IsMkRBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBUztBQUN4QjtBQUNBO0FBaUJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srZGVsZWdhdGlvbi1jb3JlQDAuMi4wL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZGVsZWdhdGlvbi1jb3JlL2Rpc3QvaW5kZXgubWpzPzExMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JldHVybnMudHNcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGhleFRvQnl0ZXMgfSBmcm9tIFwiQG1ldGFtYXNrL3V0aWxzXCI7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7IG91dDogXCJoZXhcIiB9O1xuZnVuY3Rpb24gcHJlcGFyZVJlc3VsdChyZXN1bHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMub3V0ID09PSBcImhleFwiKSB7XG4gICAgY29uc3QgaGV4VmFsdWUgPSB0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiID8gcmVzdWx0IDogYnl0ZXNUb0hleChyZXN1bHQpO1xuICAgIHJldHVybiBoZXhWYWx1ZS5zdGFydHNXaXRoKFwiMHhcIikgPyBoZXhWYWx1ZSA6IGAweCR7aGV4VmFsdWV9YDtcbiAgfVxuICBjb25zdCBieXRlc1ZhbHVlID0gcmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHJlc3VsdCA6IGhleFRvQnl0ZXMocmVzdWx0KTtcbiAgcmV0dXJuIGJ5dGVzVmFsdWU7XG59XG52YXIgYnl0ZXNMaWtlVG9IZXggPSAoYnl0ZXNMaWtlKSA9PiB7XG4gIGlmICh0eXBlb2YgYnl0ZXNMaWtlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGJ5dGVzTGlrZTtcbiAgfVxuICByZXR1cm4gYnl0ZXNUb0hleChieXRlc0xpa2UpO1xufTtcbnZhciBieXRlc0xpa2VUb0J5dGVzID0gKGJ5dGVzTGlrZSkgPT4ge1xuICBpZiAodHlwZW9mIGJ5dGVzTGlrZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGJ5dGVzTGlrZSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzTGlrZTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIHRvSGV4U3RyaW5nID0gKHtcbiAgdmFsdWUsXG4gIHNpemVcbn0pID0+IHtcbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDE2KS5wYWRTdGFydChzaXplICogMiwgXCIwXCIpO1xufTtcblxuLy8gc3JjL2NhdmVhdHMvdmFsdWVMdGUudHNcbmZ1bmN0aW9uIGNyZWF0ZVZhbHVlTHRlVGVybXModGVybXMsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICBjb25zdCB7IG1heFZhbHVlIH0gPSB0ZXJtcztcbiAgaWYgKG1heFZhbHVlIDwgMG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1heFZhbHVlOiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXCIpO1xuICB9XG4gIGNvbnN0IGhleFZhbHVlID0gdG9IZXhTdHJpbmcoeyB2YWx1ZTogbWF4VmFsdWUsIHNpemU6IDMyIH0pO1xuICByZXR1cm4gcHJlcGFyZVJlc3VsdChoZXhWYWx1ZSwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy9jYXZlYXRzL3RpbWVzdGFtcC50c1xudmFyIFRJTUVTVEFNUF9VUFBFUl9CT1VORF9TRUNPTkRTID0gMjUzNDAyMzAwNzk5O1xuZnVuY3Rpb24gY3JlYXRlVGltZXN0YW1wVGVybXModGVybXMsIGVuY29kaW5nT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IHsgdGltZXN0YW1wQWZ0ZXJUaHJlc2hvbGQsIHRpbWVzdGFtcEJlZm9yZVRocmVzaG9sZCB9ID0gdGVybXM7XG4gIGlmICh0aW1lc3RhbXBBZnRlclRocmVzaG9sZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgdGltZXN0YW1wQWZ0ZXJUaHJlc2hvbGQ6IG11c3QgYmUgemVybyBvciBwb3NpdGl2ZVwiXG4gICAgKTtcbiAgfVxuICBpZiAodGltZXN0YW1wQmVmb3JlVGhyZXNob2xkIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCB0aW1lc3RhbXBCZWZvcmVUaHJlc2hvbGQ6IG11c3QgYmUgemVybyBvciBwb3NpdGl2ZVwiXG4gICAgKTtcbiAgfVxuICBpZiAodGltZXN0YW1wQmVmb3JlVGhyZXNob2xkID4gVElNRVNUQU1QX1VQUEVSX0JPVU5EX1NFQ09ORFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB0aW1lc3RhbXBCZWZvcmVUaHJlc2hvbGQ6IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7VElNRVNUQU1QX1VQUEVSX0JPVU5EX1NFQ09ORFN9YFxuICAgICk7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcEFmdGVyVGhyZXNob2xkID4gVElNRVNUQU1QX1VQUEVSX0JPVU5EX1NFQ09ORFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCB0aW1lc3RhbXBBZnRlclRocmVzaG9sZDogbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHtUSU1FU1RBTVBfVVBQRVJfQk9VTkRfU0VDT05EU31gXG4gICAgKTtcbiAgfVxuICBpZiAodGltZXN0YW1wQmVmb3JlVGhyZXNob2xkICE9PSAwICYmIHRpbWVzdGFtcEFmdGVyVGhyZXNob2xkID49IHRpbWVzdGFtcEJlZm9yZVRocmVzaG9sZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCB0aHJlc2hvbGRzOiB0aW1lc3RhbXBCZWZvcmVUaHJlc2hvbGQgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGltZXN0YW1wQWZ0ZXJUaHJlc2hvbGQgd2hlbiBib3RoIGFyZSBzcGVjaWZpZWRcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgYWZ0ZXJUaHJlc2hvbGRIZXggPSB0b0hleFN0cmluZyh7XG4gICAgdmFsdWU6IHRpbWVzdGFtcEFmdGVyVGhyZXNob2xkLFxuICAgIHNpemU6IDE2XG4gIH0pO1xuICBjb25zdCBiZWZvcmVUaHJlc2hvbGRIZXggPSB0b0hleFN0cmluZyh7XG4gICAgdmFsdWU6IHRpbWVzdGFtcEJlZm9yZVRocmVzaG9sZCxcbiAgICBzaXplOiAxNlxuICB9KTtcbiAgY29uc3QgaGV4VmFsdWUgPSBgMHgke2FmdGVyVGhyZXNob2xkSGV4fSR7YmVmb3JlVGhyZXNob2xkSGV4fWA7XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGhleFZhbHVlLCBlbmNvZGluZ09wdGlvbnMpO1xufVxuXG4vLyBzcmMvY2F2ZWF0cy9uYXRpdmVUb2tlblBlcmlvZFRyYW5zZmVyLnRzXG5mdW5jdGlvbiBjcmVhdGVOYXRpdmVUb2tlblBlcmlvZFRyYW5zZmVyVGVybXModGVybXMsIGVuY29kaW5nT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGVyaW9kQW1vdW50LCBwZXJpb2REdXJhdGlvbiwgc3RhcnREYXRlIH0gPSB0ZXJtcztcbiAgaWYgKHBlcmlvZEFtb3VudCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVyaW9kQW1vdW50OiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChwZXJpb2REdXJhdGlvbiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwZXJpb2REdXJhdGlvbjogbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICBpZiAoc3RhcnREYXRlIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0RGF0ZTogbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCBwZXJpb2RBbW91bnRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBwZXJpb2RBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBwZXJpb2REdXJhdGlvbkhleCA9IHRvSGV4U3RyaW5nKHsgdmFsdWU6IHBlcmlvZER1cmF0aW9uLCBzaXplOiAzMiB9KTtcbiAgY29uc3Qgc3RhcnREYXRlSGV4ID0gdG9IZXhTdHJpbmcoeyB2YWx1ZTogc3RhcnREYXRlLCBzaXplOiAzMiB9KTtcbiAgY29uc3QgaGV4VmFsdWUgPSBgMHgke3BlcmlvZEFtb3VudEhleH0ke3BlcmlvZER1cmF0aW9uSGV4fSR7c3RhcnREYXRlSGV4fWA7XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGhleFZhbHVlLCBlbmNvZGluZ09wdGlvbnMpO1xufVxuXG4vLyBzcmMvY2F2ZWF0cy9leGFjdENhbGxkYXRhLnRzXG5mdW5jdGlvbiBjcmVhdGVFeGFjdENhbGxkYXRhVGVybXModGVybXMsIGVuY29kaW5nT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IHsgY2FsbGRhdGEgfSA9IHRlcm1zO1xuICBpZiAodHlwZW9mIGNhbGxkYXRhID09PSBcInN0cmluZ1wiICYmICFjYWxsZGF0YS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGxkYXRhOiBtdXN0IGJlIGEgaGV4IHN0cmluZyBzdGFydGluZyB3aXRoIDB4XCIpO1xuICB9XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGNhbGxkYXRhLCBlbmNvZGluZ09wdGlvbnMpO1xufVxuXG4vLyBzcmMvY2F2ZWF0cy9uYXRpdmVUb2tlblN0cmVhbWluZy50c1xudmFyIFRJTUVTVEFNUF9VUFBFUl9CT1VORF9TRUNPTkRTMiA9IDI1MzQwMjMwMDc5OTtcbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVRva2VuU3RyZWFtaW5nVGVybXModGVybXMsIGVuY29kaW5nT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IHsgaW5pdGlhbEFtb3VudCwgbWF4QW1vdW50LCBhbW91bnRQZXJTZWNvbmQsIHN0YXJ0VGltZSB9ID0gdGVybXM7XG4gIGlmIChpbml0aWFsQW1vdW50IDwgMG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluaXRpYWxBbW91bnQ6IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm9cIik7XG4gIH1cbiAgaWYgKG1heEFtb3VudCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWF4QW1vdW50OiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChtYXhBbW91bnQgPCBpbml0aWFsQW1vdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtYXhBbW91bnQ6IG11c3QgYmUgZ3JlYXRlciB0aGFuIGluaXRpYWxBbW91bnRcIik7XG4gIH1cbiAgaWYgKGFtb3VudFBlclNlY29uZCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYW1vdW50UGVyU2Vjb25kOiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChzdGFydFRpbWUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhcnRUaW1lOiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChzdGFydFRpbWUgPiBUSU1FU1RBTVBfVVBQRVJfQk9VTkRfU0VDT05EUzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgc3RhcnRUaW1lOiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNTM0MDIzMDA3OTlcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFtb3VudEhleCA9IHRvSGV4U3RyaW5nKHsgdmFsdWU6IGluaXRpYWxBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBtYXhBbW91bnRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBtYXhBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBhbW91bnRQZXJTZWNvbmRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBhbW91bnRQZXJTZWNvbmQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBzdGFydFRpbWVIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBzdGFydFRpbWUsIHNpemU6IDMyIH0pO1xuICBjb25zdCBoZXhWYWx1ZSA9IGAweCR7aW5pdGlhbEFtb3VudEhleH0ke21heEFtb3VudEhleH0ke2Ftb3VudFBlclNlY29uZEhleH0ke3N0YXJ0VGltZUhleH1gO1xuICByZXR1cm4gcHJlcGFyZVJlc3VsdChoZXhWYWx1ZSwgZW5jb2RpbmdPcHRpb25zKTtcbn1cblxuLy8gc3JjL2NhdmVhdHMvZXJjMjBTdHJlYW1pbmcudHNcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBtZXRhbWFzay91dGlsc1wiO1xudmFyIFRJTUVTVEFNUF9VUFBFUl9CT1VORF9TRUNPTkRTMyA9IDI1MzQwMjMwMDc5OTtcbmZ1bmN0aW9uIGNyZWF0ZUVSQzIwU3RyZWFtaW5nVGVybXModGVybXMsIGVuY29kaW5nT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IHsgdG9rZW5BZGRyZXNzLCBpbml0aWFsQW1vdW50LCBtYXhBbW91bnQsIGFtb3VudFBlclNlY29uZCwgc3RhcnRUaW1lIH0gPSB0ZXJtcztcbiAgaWYgKCF0b2tlbkFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuQWRkcmVzczogbXVzdCBiZSBhIHZhbGlkIGFkZHJlc3NcIik7XG4gIH1cbiAgbGV0IHByZWZpeGVkVG9rZW5BZGRyZXNzSGV4O1xuICBpZiAodHlwZW9mIHRva2VuQWRkcmVzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghaXNIZXhTdHJpbmcodG9rZW5BZGRyZXNzKSB8fCB0b2tlbkFkZHJlc3MubGVuZ3RoICE9PSA0Mikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbkFkZHJlc3M6IG11c3QgYmUgYSB2YWxpZCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICBwcmVmaXhlZFRva2VuQWRkcmVzc0hleCA9IHRva2VuQWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW5BZGRyZXNzLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG9rZW5BZGRyZXNzOiBtdXN0IGJlIGEgdmFsaWQgYWRkcmVzc1wiKTtcbiAgICB9XG4gICAgcHJlZml4ZWRUb2tlbkFkZHJlc3NIZXggPSBieXRlc1RvSGV4Mih0b2tlbkFkZHJlc3MpO1xuICB9XG4gIGlmIChpbml0aWFsQW1vdW50IDwgMG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluaXRpYWxBbW91bnQ6IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm9cIik7XG4gIH1cbiAgaWYgKG1heEFtb3VudCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWF4QW1vdW50OiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChtYXhBbW91bnQgPCBpbml0aWFsQW1vdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtYXhBbW91bnQ6IG11c3QgYmUgZ3JlYXRlciB0aGFuIGluaXRpYWxBbW91bnRcIik7XG4gIH1cbiAgaWYgKGFtb3VudFBlclNlY29uZCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYW1vdW50UGVyU2Vjb25kOiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChzdGFydFRpbWUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhcnRUaW1lOiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChzdGFydFRpbWUgPiBUSU1FU1RBTVBfVVBQRVJfQk9VTkRfU0VDT05EUzMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgc3RhcnRUaW1lOiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNTM0MDIzMDA3OTlcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFtb3VudEhleCA9IHRvSGV4U3RyaW5nKHsgdmFsdWU6IGluaXRpYWxBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBtYXhBbW91bnRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBtYXhBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBhbW91bnRQZXJTZWNvbmRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBhbW91bnRQZXJTZWNvbmQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBzdGFydFRpbWVIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBzdGFydFRpbWUsIHNpemU6IDMyIH0pO1xuICBjb25zdCBoZXhWYWx1ZSA9IGAke3ByZWZpeGVkVG9rZW5BZGRyZXNzSGV4fSR7aW5pdGlhbEFtb3VudEhleH0ke21heEFtb3VudEhleH0ke2Ftb3VudFBlclNlY29uZEhleH0ke3N0YXJ0VGltZUhleH1gO1xuICByZXR1cm4gcHJlcGFyZVJlc3VsdChoZXhWYWx1ZSwgZW5jb2RpbmdPcHRpb25zKTtcbn1cblxuLy8gc3JjL2NhdmVhdHMvZXJjMjBUb2tlblBlcmlvZFRyYW5zZmVyLnRzXG5pbXBvcnQgeyBpc0hleFN0cmluZyBhcyBpc0hleFN0cmluZzIsIGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDMgfSBmcm9tIFwiQG1ldGFtYXNrL3V0aWxzXCI7XG5mdW5jdGlvbiBjcmVhdGVFUkMyMFRva2VuUGVyaW9kVHJhbnNmZXJUZXJtcyh0ZXJtcywgZW5jb2RpbmdPcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgY29uc3QgeyB0b2tlbkFkZHJlc3MsIHBlcmlvZEFtb3VudCwgcGVyaW9kRHVyYXRpb24sIHN0YXJ0RGF0ZSB9ID0gdGVybXM7XG4gIGlmICghdG9rZW5BZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbkFkZHJlc3M6IG11c3QgYmUgYSB2YWxpZCBhZGRyZXNzXCIpO1xuICB9XG4gIGxldCBwcmVmaXhlZFRva2VuQWRkcmVzc0hleDtcbiAgaWYgKHR5cGVvZiB0b2tlbkFkZHJlc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nMih0b2tlbkFkZHJlc3MpIHx8IHRva2VuQWRkcmVzcy5sZW5ndGggIT09IDQyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuQWRkcmVzczogbXVzdCBiZSBhIHZhbGlkIGFkZHJlc3NcIik7XG4gICAgfVxuICAgIHByZWZpeGVkVG9rZW5BZGRyZXNzSGV4ID0gdG9rZW5BZGRyZXNzO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbkFkZHJlc3MubGVuZ3RoICE9PSAyMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbkFkZHJlc3M6IG11c3QgYmUgYSB2YWxpZCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICBwcmVmaXhlZFRva2VuQWRkcmVzc0hleCA9IGJ5dGVzVG9IZXgzKHRva2VuQWRkcmVzcyk7XG4gIH1cbiAgaWYgKHBlcmlvZEFtb3VudCA8PSAwbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVyaW9kQW1vdW50OiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIGlmIChwZXJpb2REdXJhdGlvbiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwZXJpb2REdXJhdGlvbjogbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICBpZiAoc3RhcnREYXRlIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0RGF0ZTogbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCBwZXJpb2RBbW91bnRIZXggPSB0b0hleFN0cmluZyh7IHZhbHVlOiBwZXJpb2RBbW91bnQsIHNpemU6IDMyIH0pO1xuICBjb25zdCBwZXJpb2REdXJhdGlvbkhleCA9IHRvSGV4U3RyaW5nKHsgdmFsdWU6IHBlcmlvZER1cmF0aW9uLCBzaXplOiAzMiB9KTtcbiAgY29uc3Qgc3RhcnREYXRlSGV4ID0gdG9IZXhTdHJpbmcoeyB2YWx1ZTogc3RhcnREYXRlLCBzaXplOiAzMiB9KTtcbiAgY29uc3QgaGV4VmFsdWUgPSBgJHtwcmVmaXhlZFRva2VuQWRkcmVzc0hleH0ke3BlcmlvZEFtb3VudEhleH0ke3BlcmlvZER1cmF0aW9uSGV4fSR7c3RhcnREYXRlSGV4fWA7XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGhleFZhbHVlLCBlbmNvZGluZ09wdGlvbnMpO1xufVxuXG4vLyBzcmMvY2F2ZWF0cy9ub25jZS50c1xuaW1wb3J0IHsgaXNIZXhTdHJpbmcgYXMgaXNIZXhTdHJpbmczIH0gZnJvbSBcIkBtZXRhbWFzay91dGlsc1wiO1xudmFyIE1BWF9OT05DRV9TVFJJTkdfTEVOR1RIID0gNjY7XG5mdW5jdGlvbiBjcmVhdGVOb25jZVRlcm1zKHRlcm1zLCBlbmNvZGluZ09wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICBjb25zdCB7IG5vbmNlIH0gPSB0ZXJtcztcbiAgaWYgKG5vbmNlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBub25jZS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vbmNlOiBVaW50OEFycmF5IG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygbm9uY2UgPT09IFwic3RyaW5nXCIgJiYgIW5vbmNlLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9uY2U6IHN0cmluZyBtdXN0IGhhdmUgMHggcHJlZml4XCIpO1xuICB9XG4gIGNvbnN0IGhleE5vbmNlID0gYnl0ZXNMaWtlVG9IZXgobm9uY2UpO1xuICBpZiAoaGV4Tm9uY2UgPT09IFwiMHhcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9uY2U6IG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG4gIGlmICghaXNIZXhTdHJpbmczKGhleE5vbmNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9uY2U6IG11c3QgYmUgYSB2YWxpZCBCeXRlc0xpa2UgdmFsdWVcIik7XG4gIH1cbiAgaWYgKGhleE5vbmNlLmxlbmd0aCA+IE1BWF9OT05DRV9TVFJJTkdfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub25jZTogbXVzdCBiZSAzMiBieXRlcyBvciBsZXNzIGluIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBub25jZVdpdGhvdXRQcmVmaXggPSBoZXhOb25jZS5zbGljZSgyKTtcbiAgY29uc3QgcGFkZGVkTm9uY2UgPSBub25jZVdpdGhvdXRQcmVmaXgucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgY29uc3QgaGV4VmFsdWUgPSBgMHgke3BhZGRlZE5vbmNlfWA7XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGhleFZhbHVlLCBlbmNvZGluZ09wdGlvbnMpO1xufVxuXG4vLyBzcmMvZGVsZWdhdGlvbi50c1xuaW1wb3J0IHsgZW5jb2RlLCBlbmNvZGVTaW5nbGUsIGRlY29kZVNpbmdsZSB9IGZyb20gXCJAbWV0YW1hc2svYWJpLXV0aWxzXCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXMyIH0gZnJvbSBcIkBtZXRhbWFzay91dGlsc1wiO1xuaW1wb3J0IHsga2VjY2FrXzI1NiBhcyBrZWNjYWsyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG52YXIgQU5ZX0JFTkVGSUNJQVJZID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMTFcIjtcbnZhciBST09UX0FVVEhPUklUWSA9IFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCI7XG52YXIgREVMRUdBVElPTl9UWVBFSEFTSCA9IFwiMHg4OGMxZDJlY2YxODVhZGY3MTA1ODgyMDNhNWYyNjNmMGZmNjFiZTBkMzNkYTM5NzkyY2RlMTliYTlhYTQzMzFlXCI7XG52YXIgQ0FWRUFUX1RZUEVIQVNIID0gXCIweDgwYWQ3ZTFiMDRlZTZkOTk0YTEyNWY0NzE0Y2EwNzIwOTA4YmQ4MGVkMTYwNjNlYzhhZWU0Yjg4ZTkyNTNlMmRcIjtcbnZhciBERUxFR0FUSU9OX0FSUkFZX0FCSV9UWVBFUyA9IFwiKGFkZHJlc3MsYWRkcmVzcyxieXRlczMyLChhZGRyZXNzLGJ5dGVzLGJ5dGVzKVtdLHVpbnQyNTYsYnl0ZXMpW11cIjtcbmZ1bmN0aW9uIGVuY29kZURlbGVnYXRpb25zKGRlbGVnYXRpb25zLCBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGRlbGVnYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICByZXN1bHRbMzFdID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZW5jb2RhYmxlU3RydWN0cyA9IGRlbGVnYXRpb25zLm1hcCgoc3RydWN0KSA9PiBbXG4gICAgICBzdHJ1Y3QuZGVsZWdhdGUsXG4gICAgICBzdHJ1Y3QuZGVsZWdhdG9yLFxuICAgICAgc3RydWN0LmF1dGhvcml0eSxcbiAgICAgIHN0cnVjdC5jYXZlYXRzLm1hcCgoY2F2ZWF0KSA9PiBbXG4gICAgICAgIGNhdmVhdC5lbmZvcmNlcixcbiAgICAgICAgY2F2ZWF0LnRlcm1zLFxuICAgICAgICBjYXZlYXQuYXJnc1xuICAgICAgXSksXG4gICAgICBzdHJ1Y3Quc2FsdCxcbiAgICAgIHN0cnVjdC5zaWduYXR1cmVcbiAgICBdKTtcbiAgICByZXN1bHQgPSBlbmNvZGVTaW5nbGUoREVMRUdBVElPTl9BUlJBWV9BQklfVFlQRVMsIGVuY29kYWJsZVN0cnVjdHMpO1xuICB9XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KHJlc3VsdCwgb3B0aW9ucyk7XG59XG52YXIgZGVsZWdhdGlvbkZyb21EZWNvZGVkRGVsZWdhdGlvbiA9IChkZWNvZGVkRGVsZWdhdGlvbiwgY29udmVydEZuKSA9PiB7XG4gIGNvbnN0IFtkZWxlZ2F0ZSwgZGVsZWdhdG9yLCBhdXRob3JpdHksIGNhdmVhdHMsIHNhbHQsIHNpZ25hdHVyZV0gPSBkZWNvZGVkRGVsZWdhdGlvbjtcbiAgcmV0dXJuIHtcbiAgICBkZWxlZ2F0ZTogY29udmVydEZuKGRlbGVnYXRlKSxcbiAgICBkZWxlZ2F0b3I6IGNvbnZlcnRGbihkZWxlZ2F0b3IpLFxuICAgIGF1dGhvcml0eTogY29udmVydEZuKGF1dGhvcml0eSksXG4gICAgY2F2ZWF0czogY2F2ZWF0cy5tYXAoKFtlbmZvcmNlciwgdGVybXMsIGFyZ3NdKSA9PiAoe1xuICAgICAgZW5mb3JjZXI6IGNvbnZlcnRGbihlbmZvcmNlciksXG4gICAgICB0ZXJtczogY29udmVydEZuKHRlcm1zKSxcbiAgICAgIGFyZ3M6IGNvbnZlcnRGbihhcmdzKVxuICAgIH0pKSxcbiAgICBzYWx0LFxuICAgIHNpZ25hdHVyZTogY29udmVydEZuKHNpZ25hdHVyZSlcbiAgfTtcbn07XG5mdW5jdGlvbiBkZWNvZGVEZWxlZ2F0aW9ucyhlbmNvZGVkLCBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgY29uc3QgZGVjb2RlZFN0cnVjdHMgPSBkZWNvZGVTaW5nbGUoXG4gICAgREVMRUdBVElPTl9BUlJBWV9BQklfVFlQRVMsXG4gICAgZW5jb2RlZFxuICAgIC8vIHJldHVybiB0eXBlcyBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBjb21wbGV4IEFCSSB0eXBlcywgc28gd2UgbXVzdCBhc3NlcnQgdGhlIHR5cGVcbiAgKTtcbiAgaWYgKG9wdGlvbnMub3V0ID09PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gZGVjb2RlZFN0cnVjdHMubWFwKFxuICAgICAgKHN0cnVjdCkgPT4gZGVsZWdhdGlvbkZyb21EZWNvZGVkRGVsZWdhdGlvbihzdHJ1Y3QsIGJ5dGVzTGlrZVRvQnl0ZXMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZFN0cnVjdHMubWFwKFxuICAgIChzdHJ1Y3QpID0+IGRlbGVnYXRpb25Gcm9tRGVjb2RlZERlbGVnYXRpb24oc3RydWN0LCBieXRlc0xpa2VUb0hleClcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hEZWxlZ2F0aW9uKGRlbGVnYXRpb24sIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICBjb25zdCBlbmNvZGVkID0gZW5jb2RlKFxuICAgIFtcImJ5dGVzMzJcIiwgXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBcImJ5dGVzMzJcIiwgXCJieXRlczMyXCIsIFwidWludDI1NlwiXSxcbiAgICBbXG4gICAgICBERUxFR0FUSU9OX1RZUEVIQVNILFxuICAgICAgZGVsZWdhdGlvbi5kZWxlZ2F0ZSxcbiAgICAgIGRlbGVnYXRpb24uZGVsZWdhdG9yLFxuICAgICAgZGVsZWdhdGlvbi5hdXRob3JpdHksXG4gICAgICBnZXRDYXZlYXRzQXJyYXlIYXNoKGRlbGVnYXRpb24uY2F2ZWF0cyksXG4gICAgICBkZWxlZ2F0aW9uLnNhbHRcbiAgICBdXG4gICk7XG4gIGNvbnN0IGhhc2ggPSBrZWNjYWsyNTYoZW5jb2RlZCk7XG4gIHJldHVybiBwcmVwYXJlUmVzdWx0KGhhc2gsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0Q2F2ZWF0c0FycmF5SGFzaChjYXZlYXRzKSB7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSAzMiAqIGNhdmVhdHMubGVuZ3RoO1xuICBjb25zdCBlbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2F2ZWF0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNhdmVhdCA9IGNhdmVhdHNbaV07XG4gICAgaWYgKCFjYXZlYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2F2ZWF0IHdhcyB1bmRlZmluZWQgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgICBjb25zdCBjYXZlYXRIYXNoID0gZ2V0Q2F2ZWF0SGFzaChjYXZlYXQpO1xuICAgIGVuY29kZWQuc2V0KGNhdmVhdEhhc2gsIGkgKiAzMik7XG4gIH1cbiAgcmV0dXJuIGtlY2NhazI1NihlbmNvZGVkKTtcbn1cbmZ1bmN0aW9uIGdldENhdmVhdEhhc2goY2F2ZWF0KSB7XG4gIGNvbnN0IHRlcm1zQnl0ZXMgPSB0eXBlb2YgY2F2ZWF0LnRlcm1zID09PSBcInN0cmluZ1wiID8gaGV4VG9CeXRlczIoY2F2ZWF0LnRlcm1zKSA6IGNhdmVhdC50ZXJtcztcbiAgY29uc3QgdGVybXNIYXNoID0ga2VjY2FrMjU2KHRlcm1zQnl0ZXMpO1xuICBjb25zdCBlbmNvZGVkID0gZW5jb2RlKFxuICAgIFtcImJ5dGVzMzJcIiwgXCJhZGRyZXNzXCIsIFwiYnl0ZXMzMlwiXSxcbiAgICBbQ0FWRUFUX1RZUEVIQVNILCBjYXZlYXQuZW5mb3JjZXIsIHRlcm1zSGFzaF1cbiAgKTtcbiAgY29uc3QgaGFzaCA9IGtlY2NhazI1NihlbmNvZGVkKTtcbiAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnQge1xuICBBTllfQkVORUZJQ0lBUlksXG4gIENBVkVBVF9UWVBFSEFTSCxcbiAgREVMRUdBVElPTl9UWVBFSEFTSCxcbiAgUk9PVF9BVVRIT1JJVFksXG4gIGNyZWF0ZUVSQzIwU3RyZWFtaW5nVGVybXMsXG4gIGNyZWF0ZUVSQzIwVG9rZW5QZXJpb2RUcmFuc2ZlclRlcm1zLFxuICBjcmVhdGVFeGFjdENhbGxkYXRhVGVybXMsXG4gIGNyZWF0ZU5hdGl2ZVRva2VuUGVyaW9kVHJhbnNmZXJUZXJtcyxcbiAgY3JlYXRlTmF0aXZlVG9rZW5TdHJlYW1pbmdUZXJtcyxcbiAgY3JlYXRlTm9uY2VUZXJtcyxcbiAgY3JlYXRlVGltZXN0YW1wVGVybXMsXG4gIGNyZWF0ZVZhbHVlTHRlVGVybXMsXG4gIGRlY29kZURlbGVnYXRpb25zLFxuICBlbmNvZGVEZWxlZ2F0aW9ucyxcbiAgaGFzaERlbGVnYXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+delegation-core@0.2.0/node_modules/@metamask/delegation-core/dist/index.mjs\n");

/***/ })

};
;