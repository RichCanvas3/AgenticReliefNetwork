"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask+utils@11.8.1";
exports.ids = ["vendor-chunks/@metamask+utils@11.8.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.cjs\");\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0, errors_1.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\nexports.assertExhaustive = assertExhaustive;\n//# sourceMappingURL=assert.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLHNCQUFzQjtBQUN6RixzQkFBc0IsbUJBQU8sQ0FBQywySUFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsd0hBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRSxJQUFJLGFBQWE7QUFDakI7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxJQUFJLDRDQUE0QztBQUNwRztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmNqcz80ODBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiBmbj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBvYnRhaW4gdGhlIG1lc3NhZ2UgZnJvbSBhIHBvc3NpYmxlIGVycm9yIG9iamVjdC4gSWYgaXQgaXNcbiAqIHBvc3NpYmxlIHRvIGRvIHNvLCBhbnkgdHJhaWxpbmcgcGVyaW9kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtZXNzYWdlO1xuICogb3RoZXJ3aXNlIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2Ugd2l0aG91dCBhbnkgdHJhaWxpbmcgcGVyaW9kIGlmIGBlcnJvcmAgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5OyB0aGUgc3RyaW5nIHZlcnNpb24gb2YgYGVycm9yYCB3aXRob3V0IGFueSB0cmFpbGluZ1xuICogcGVyaW9kIGlmIGl0IGlzIG5vdCBgdW5kZWZpbmVkYCBvciBgbnVsbGA7IG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcikge1xuICAgIC8vIFdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICByZXR1cm4gKDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgJycpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/base64.cjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/base64.cjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nconst base64 = (struct, options = {}) => {\n    const paddingRequired = options.paddingRequired ?? false;\n    const characterSet = options.characterSet ?? 'base64';\n    let letters;\n    if (characterSet === 'base64') {\n        letters = String.raw `[A-Za-z0-9+\\/]`;\n    }\n    else {\n        (0, assert_1.assert)(characterSet === 'base64url');\n        letters = String.raw `[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64;\n//# sourceMappingURL=base64.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLHNCQUFzQixtQkFBTyxDQUFDLDJJQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3SEFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU8sU0FBUyxFQUFFLElBQUksU0FBUyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU8sU0FBUyxJQUFJLEdBQUcsU0FBUyxFQUFFLElBQUksU0FBUyxFQUFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5janM/ZmQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID8/IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0ID8/ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/base64.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.cjs":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.cjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areUint8ArraysEqual = exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.base64ToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToBase64 = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/../../node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return () => {\n        if (lookupTable.length === 0) {\n            for (let i = 0; i < 256; i++) {\n                lookupTable.push(i.toString(16).padStart(2, '0'));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return '0x';\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(''));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes) {\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return base_1.base64.encode(bytes);\n}\nexports.bytesToBase64 = bytesToBase64;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n    // \"0x\" is often used as empty byte array.\n    if (value?.toLowerCase?.() === '0x') {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 -\n            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        const n2 = c2 -\n            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */\n    const mask = value >> BigInt(31);\n    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n    /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction base64ToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return base_1.base64.decode(value);\n}\nexports.base64ToBytes = base64ToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n    if (typeof value === 'bigint') {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === 'number') {\n        return numberToBytes(value);\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('0x')) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for (let i = 0; i < values.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView;\n/**\n * Compare two Uint8Arrays using a constant-time style loop to reduce timing\n * side-channels when comparing sensitive data (e.g., mnemonic bytes, keys,\n * authentication tags). Does not early-return on the first difference:\n * work done depends only on the input lengths, so byte content does not affect timing.\n *\n * When to use:\n * - Use for secret or security-sensitive byte comparisons to avoid content-based timing leaks.\n * - Prefer when inputs are fixed-length (or validated to equal length) at the API boundary.\n *\n * @param a - The first Uint8Array to compare.\n * @param b - The second Uint8Array to compare.\n * @returns Whether the Uint8Arrays are equal.\n */\nfunction areUint8ArraysEqual(a, b) {\n    // eslint-disable-next-line no-bitwise\n    let diff = a.byteLength ^ b.byteLength;\n    const len = Math.max(a.byteLength, b.byteLength);\n    for (let i = 0; i < len; i++) {\n        const aByte = a[i] ?? 0;\n        const bByte = b[i] ?? 0;\n        // eslint-disable-next-line no-bitwise\n        diff |= aByte ^ bByte;\n    }\n    return diff === 0;\n}\nexports.areUint8ArraysEqual = areUint8ArraysEqual;\n//# sourceMappingURL=bytes.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlO0FBQ2piLGVBQWUsbUJBQU8sQ0FBQywyR0FBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyx3SEFBYztBQUN2QyxjQUFjLG1CQUFPLENBQUMsa0hBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsY0FBYztBQUMvRjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCLElBQUksb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxhQUFhLGdCQUFnQixRQUFRLGlCQUFpQjtBQUN0RCw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQsSUFBSSxrQkFBa0Isb0JBQW9CLDBCQUEwQjtBQUNwRTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0QsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuY2pzP2IwYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFyZVVpbnQ4QXJyYXlzRXF1YWwgPSBleHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvQmFzZTY0ID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJhc2VfMS5iYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0Jhc2U2NCA9IGJ5dGVzVG9CYXNlNjQ7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICh2YWx1ZT8udG9Mb3dlckNhc2U/LigpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gYmFzZTY0VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLyoqXG4gKiBDb21wYXJlIHR3byBVaW50OEFycmF5cyB1c2luZyBhIGNvbnN0YW50LXRpbWUgc3R5bGUgbG9vcCB0byByZWR1Y2UgdGltaW5nXG4gKiBzaWRlLWNoYW5uZWxzIHdoZW4gY29tcGFyaW5nIHNlbnNpdGl2ZSBkYXRhIChlLmcuLCBtbmVtb25pYyBieXRlcywga2V5cyxcbiAqIGF1dGhlbnRpY2F0aW9uIHRhZ3MpLiBEb2VzIG5vdCBlYXJseS1yZXR1cm4gb24gdGhlIGZpcnN0IGRpZmZlcmVuY2U6XG4gKiB3b3JrIGRvbmUgZGVwZW5kcyBvbmx5IG9uIHRoZSBpbnB1dCBsZW5ndGhzLCBzbyBieXRlIGNvbnRlbnQgZG9lcyBub3QgYWZmZWN0IHRpbWluZy5cbiAqXG4gKiBXaGVuIHRvIHVzZTpcbiAqIC0gVXNlIGZvciBzZWNyZXQgb3Igc2VjdXJpdHktc2Vuc2l0aXZlIGJ5dGUgY29tcGFyaXNvbnMgdG8gYXZvaWQgY29udGVudC1iYXNlZCB0aW1pbmcgbGVha3MuXG4gKiAtIFByZWZlciB3aGVuIGlucHV0cyBhcmUgZml4ZWQtbGVuZ3RoIChvciB2YWxpZGF0ZWQgdG8gZXF1YWwgbGVuZ3RoKSBhdCB0aGUgQVBJIGJvdW5kYXJ5LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIGZpcnN0IFVpbnQ4QXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBVaW50OEFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBVaW50OEFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIGFyZVVpbnQ4QXJyYXlzRXF1YWwoYSwgYikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgbGV0IGRpZmYgPSBhLmJ5dGVMZW5ndGggXiBiLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgbGVuID0gTWF0aC5tYXgoYS5ieXRlTGVuZ3RoLCBiLmJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYUJ5dGUgPSBhW2ldID8/IDA7XG4gICAgICAgIGNvbnN0IGJCeXRlID0gYltpXSA/PyAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBkaWZmIHw9IGFCeXRlIF4gYkJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuZXhwb3J0cy5hcmVVaW50OEFycmF5c0VxdWFsID0gYXJlVWludDhBcnJheXNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/caip-types.cjs":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/caip-types.cjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toCaipAssetId = exports.toCaipAssetType = exports.toCaipAccountId = exports.toCaipChainId = exports.parseCaipAssetId = exports.parseCaipAssetType = exports.parseCaipAccountId = exports.parseCaipChainId = exports.isCaipAssetId = exports.isCaipAssetType = exports.isCaipTokenId = exports.isCaipAssetReference = exports.isCaipAssetNamespace = exports.isCaipAccountAddress = exports.isCaipAccountId = exports.isCaipReference = exports.isCaipNamespace = exports.isCaipChainId = exports.KnownCaipNamespace = exports.CaipAssetTypeOrIdStruct = exports.CaipAssetIdStruct = exports.CaipAssetTypeStruct = exports.CaipTokenIdStruct = exports.CaipAssetReferenceStruct = exports.CaipAssetNamespaceStruct = exports.CaipAccountAddressStruct = exports.CaipAccountIdStruct = exports.CaipReferenceStruct = exports.CaipNamespaceStruct = exports.CaipChainIdStruct = exports.CAIP_ASSET_ID_REGEX = exports.CAIP_ASSET_TYPE_REGEX = exports.CAIP_TOKEN_ID_REGEX = exports.CAIP_ASSET_REFERENCE_REGEX = exports.CAIP_ASSET_NAMESPACE_REGEX = exports.CAIP_ACCOUNT_ADDRESS_REGEX = exports.CAIP_ACCOUNT_ID_REGEX = exports.CAIP_REFERENCE_REGEX = exports.CAIP_NAMESPACE_REGEX = exports.CAIP_CHAIN_ID_REGEX = void 0;\nconst superstruct_1 = __webpack_require__(/*! ./superstruct.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/superstruct.cjs\");\nexports.CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nexports.CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nexports.CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexports.CAIP_ASSET_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_ASSET_REFERENCE_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nexports.CAIP_TOKEN_ID_REGEX = /^[-.%a-zA-Z0-9]{1,78}$/u;\nexports.CAIP_ASSET_TYPE_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ASSET_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78})$/u;\nconst CAIP_ASSET_TYPE_OR_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})(\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78}))?$/u;\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexports.CaipChainIdStruct = (0, superstruct_1.definePattern)('CaipChainId', exports.CAIP_CHAIN_ID_REGEX);\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexports.CaipNamespaceStruct = (0, superstruct_1.definePattern)('CaipNamespace', exports.CAIP_NAMESPACE_REGEX);\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexports.CaipReferenceStruct = (0, superstruct_1.definePattern)('CaipReference', exports.CAIP_REFERENCE_REGEX);\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexports.CaipAccountIdStruct = (0, superstruct_1.definePattern)('CaipAccountId', exports.CAIP_ACCOUNT_ID_REGEX);\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexports.CaipAccountAddressStruct = (0, superstruct_1.definePattern)('CaipAccountAddress', exports.CAIP_ACCOUNT_ADDRESS_REGEX);\n/**\n * A CAIP-19 asset namespace, i.e., a namespace domain of an asset.\n */\nexports.CaipAssetNamespaceStruct = (0, superstruct_1.definePattern)('CaipAssetNamespace', exports.CAIP_ASSET_NAMESPACE_REGEX);\n/**\n * A CAIP-19 asset reference, i.e., an identifier for an asset within a given namespace.\n */\nexports.CaipAssetReferenceStruct = (0, superstruct_1.definePattern)('CaipAssetReference', exports.CAIP_ASSET_REFERENCE_REGEX);\n/**\n * A CAIP-19 asset token ID, i.e., a unique identifier for an addressable asset of a given type\n */\nexports.CaipTokenIdStruct = (0, superstruct_1.definePattern)('CaipTokenId', exports.CAIP_TOKEN_ID_REGEX);\n/**\n * A CAIP-19 asset type identifier, i.e., a human-readable type of asset identifier.\n */\nexports.CaipAssetTypeStruct = (0, superstruct_1.definePattern)('CaipAssetType', exports.CAIP_ASSET_TYPE_REGEX);\n/**\n * A CAIP-19 asset ID identifier, i.e., a human-readable type of asset ID.\n */\nexports.CaipAssetIdStruct = (0, superstruct_1.definePattern)('CaipAssetId', exports.CAIP_ASSET_ID_REGEX);\n/**\n * A CAIP-19 asset type or asset ID identifier, i.e., a human-readable type of asset identifier.\n */\nexports.CaipAssetTypeOrIdStruct = (0, superstruct_1.definePattern)('CaipAssetTypeOrId', CAIP_ASSET_TYPE_OR_ID_REGEX);\n/** Known CAIP namespaces. */\nvar KnownCaipNamespace;\n(function (KnownCaipNamespace) {\n    /** BIP-122 (Bitcoin) compatible chains. */\n    KnownCaipNamespace[\"Bip122\"] = \"bip122\";\n    /** Solana compatible chains */\n    KnownCaipNamespace[\"Solana\"] = \"solana\";\n    /** Tron compatible chains */\n    KnownCaipNamespace[\"Tron\"] = \"tron\";\n    /** EIP-155 compatible chains. */\n    KnownCaipNamespace[\"Eip155\"] = \"eip155\";\n    KnownCaipNamespace[\"Wallet\"] = \"wallet\";\n})(KnownCaipNamespace = exports.KnownCaipNamespace || (exports.KnownCaipNamespace = {}));\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nfunction isCaipChainId(value) {\n    return typeof value === 'string' && exports.CAIP_CHAIN_ID_REGEX.test(value);\n}\nexports.isCaipChainId = isCaipChainId;\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nfunction isCaipNamespace(value) {\n    return typeof value === 'string' && exports.CAIP_NAMESPACE_REGEX.test(value);\n}\nexports.isCaipNamespace = isCaipNamespace;\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nfunction isCaipReference(value) {\n    return typeof value === 'string' && exports.CAIP_REFERENCE_REGEX.test(value);\n}\nexports.isCaipReference = isCaipReference;\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nfunction isCaipAccountId(value) {\n    return typeof value === 'string' && exports.CAIP_ACCOUNT_ID_REGEX.test(value);\n}\nexports.isCaipAccountId = isCaipAccountId;\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nfunction isCaipAccountAddress(value) {\n    return typeof value === 'string' && exports.CAIP_ACCOUNT_ADDRESS_REGEX.test(value);\n}\nexports.isCaipAccountAddress = isCaipAccountAddress;\n/**\n * Check if the given value is a {@link CaipAssetNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetNamespace}.\n */\nfunction isCaipAssetNamespace(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_NAMESPACE_REGEX.test(value);\n}\nexports.isCaipAssetNamespace = isCaipAssetNamespace;\n/**\n * Check if the given value is a {@link CaipAssetReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetReference}.\n */\nfunction isCaipAssetReference(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_REFERENCE_REGEX.test(value);\n}\nexports.isCaipAssetReference = isCaipAssetReference;\n/**\n * Check if the given value is a {@link CaipTokenId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipTokenId}.\n */\nfunction isCaipTokenId(value) {\n    return typeof value === 'string' && exports.CAIP_TOKEN_ID_REGEX.test(value);\n}\nexports.isCaipTokenId = isCaipTokenId;\n/**\n * Check if the given value is a {@link CaipAssetType}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetType}.\n */\nfunction isCaipAssetType(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_TYPE_REGEX.test(value);\n}\nexports.isCaipAssetType = isCaipAssetType;\n/**\n * Check if the given value is a {@link CaipAssetId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetId}.\n */\nfunction isCaipAssetId(value) {\n    return typeof value === 'string' && exports.CAIP_ASSET_ID_REGEX.test(value);\n}\nexports.isCaipAssetId = isCaipAssetId;\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nfunction parseCaipChainId(caipChainId) {\n    const match = exports.CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP chain ID.');\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference,\n    };\n}\nexports.parseCaipChainId = parseCaipChainId;\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nfunction parseCaipAccountId(caipAccountId) {\n    const match = exports.CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP account ID.');\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAccountId = parseCaipAccountId;\n/**\n * Parse a CAIP-19 asset type to an object containing the chain ID, parsed chain ID,\n * asset namespace, and asset reference\n *\n * This validates the CAIP-19 asset type before parsing it.\n *\n * @param caipAssetType - The CAIP-19 asset type to validate and parse.\n * @returns The parsed CAIP-19 asset type.\n */\nfunction parseCaipAssetType(caipAssetType) {\n    const match = exports.CAIP_ASSET_TYPE_REGEX.exec(caipAssetType);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset type.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAssetType = parseCaipAssetType;\n/**\n * Parse a CAIP-19 asset ID to an object containing the chain ID, parsed chain ID,\n * asset namespace, asset reference, and token ID.\n *\n * This validates the CAIP-19 asset ID before parsing it.\n *\n * @param caipAssetId - The CAIP-19 asset ID to validate and parse.\n * @returns The parsed CAIP-19 asset ID.\n */\nfunction parseCaipAssetId(caipAssetId) {\n    const match = exports.CAIP_ASSET_ID_REGEX.exec(caipAssetId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP asset ID.');\n    }\n    return {\n        assetNamespace: match.groups.assetNamespace,\n        assetReference: match.groups.assetReference,\n        tokenId: match.groups.tokenId,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAssetId = parseCaipAssetId;\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nfunction toCaipChainId(namespace, reference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}`;\n}\nexports.toCaipChainId = toCaipChainId;\n/**\n * Account ID as defined per the CAIP-10\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md}.\n *\n * It defines a way to uniquely identify any blockchain account in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param accountAddress - The address of the blockchain account.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-10\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md#syntax}.\n * @returns A CAIP account ID.\n */\nfunction toCaipAccountId(namespace, reference, accountAddress) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAccountAddress(accountAddress)) {\n        throw new Error(`Invalid \"accountAddress\", must match: ${exports.CAIP_ACCOUNT_ADDRESS_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}:${accountAddress}`;\n}\nexports.toCaipAccountId = toCaipAccountId;\n/**\n * Asset Type as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset type.\n */\nfunction toCaipAssetType(namespace, reference, assetNamespace, assetReference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${exports.CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${exports.CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}`;\n}\nexports.toCaipAssetType = toCaipAssetType;\n/**\n * Asset ID as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @param tokenId - The unique identifier for an addressable asset of a given type.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset ID.\n */\nfunction toCaipAssetId(namespace, reference, assetNamespace, assetReference, tokenId) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetNamespace(assetNamespace)) {\n        throw new Error(`Invalid \"assetNamespace\", must match: ${exports.CAIP_ASSET_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipAssetReference(assetReference)) {\n        throw new Error(`Invalid \"assetReference\", must match: ${exports.CAIP_ASSET_REFERENCE_REGEX.toString()}`);\n    }\n    if (!isCaipTokenId(tokenId)) {\n        throw new Error(`Invalid \"tokenId\", must match: ${exports.CAIP_TOKEN_ID_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}/${assetNamespace}:${assetReference}/${tokenId}`;\n}\nexports.toCaipAssetId = toCaipAssetId;\n//# sourceMappingURL=caip-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NhaXAtdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLDZCQUE2QixHQUFHLDJCQUEyQixHQUFHLGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDJCQUEyQjtBQUN6cEMsc0JBQXNCLG1CQUFPLENBQUMsa0lBQW1CO0FBQ2pELDJCQUEyQiw0QkFBNEIsSUFBSSw2QkFBNkIsS0FBSztBQUM3Riw0QkFBNEIsZUFBZSxJQUFJO0FBQy9DLDRCQUE0QixtQkFBbUIsS0FBSztBQUNwRCw2QkFBNkIsdUNBQXVDLElBQUksNkJBQTZCLEtBQUssb0NBQW9DLE1BQU07QUFDcEosa0NBQWtDLG9CQUFvQixNQUFNO0FBQzVELGtDQUFrQyxlQUFlLElBQUk7QUFDckQsa0NBQWtDLG9CQUFvQixNQUFNO0FBQzVELDJCQUEyQixvQkFBb0IsS0FBSztBQUNwRCw2QkFBNkIsdUNBQXVDLElBQUksNkJBQTZCLEtBQUssZ0NBQWdDLElBQUksbUNBQW1DLE1BQU07QUFDdkwsMkJBQTJCLHVDQUF1QyxJQUFJLDZCQUE2QixLQUFLLGdDQUFnQyxJQUFJLG1DQUFtQyxNQUFNLDZCQUE2QixLQUFLO0FBQ3ZOLHdFQUF3RSxJQUFJLDZCQUE2QixLQUFLLGdDQUFnQyxJQUFJLG1DQUFtQyxNQUFNLDhCQUE4QixLQUFLO0FBQzlOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0QsMEJBQTBCLEtBQUs7QUFDdEY7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsSUFBSSx1RUFBdUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDhFQUE4RTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQSxjQUFjLFVBQVUsR0FBRyxVQUFVO0FBQ3JDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHdFQUF3RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsSUFBSSwrRUFBK0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0NBQXdDO0FBQ3BHO0FBQ0E7QUFDQSw0REFBNEQsd0NBQXdDO0FBQ3BHO0FBQ0E7QUFDQSxpRUFBaUUsOENBQThDO0FBQy9HO0FBQ0EsY0FBYyxVQUFVLEdBQUcsVUFBVSxHQUFHLGVBQWU7QUFDdkQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLElBQUksd0VBQXdFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksK0VBQStFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBLGNBQWMsVUFBVSxHQUFHLFVBQVUsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUN6RTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsSUFBSSx3RUFBd0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLCtFQUErRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBOEM7QUFDL0c7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBOEM7QUFDL0c7QUFDQTtBQUNBLDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQSxjQUFjLFVBQVUsR0FBRyxVQUFVLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxRQUFRO0FBQ3BGO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2FpcC10eXBlcy5janM/ODFhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9DYWlwQXNzZXRJZCA9IGV4cG9ydHMudG9DYWlwQXNzZXRUeXBlID0gZXhwb3J0cy50b0NhaXBBY2NvdW50SWQgPSBleHBvcnRzLnRvQ2FpcENoYWluSWQgPSBleHBvcnRzLnBhcnNlQ2FpcEFzc2V0SWQgPSBleHBvcnRzLnBhcnNlQ2FpcEFzc2V0VHlwZSA9IGV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gZXhwb3J0cy5wYXJzZUNhaXBDaGFpbklkID0gZXhwb3J0cy5pc0NhaXBBc3NldElkID0gZXhwb3J0cy5pc0NhaXBBc3NldFR5cGUgPSBleHBvcnRzLmlzQ2FpcFRva2VuSWQgPSBleHBvcnRzLmlzQ2FpcEFzc2V0UmVmZXJlbmNlID0gZXhwb3J0cy5pc0NhaXBBc3NldE5hbWVzcGFjZSA9IGV4cG9ydHMuaXNDYWlwQWNjb3VudEFkZHJlc3MgPSBleHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGV4cG9ydHMuaXNDYWlwUmVmZXJlbmNlID0gZXhwb3J0cy5pc0NhaXBOYW1lc3BhY2UgPSBleHBvcnRzLmlzQ2FpcENoYWluSWQgPSBleHBvcnRzLktub3duQ2FpcE5hbWVzcGFjZSA9IGV4cG9ydHMuQ2FpcEFzc2V0VHlwZU9ySWRTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBc3NldElkU3RydWN0ID0gZXhwb3J0cy5DYWlwQXNzZXRUeXBlU3RydWN0ID0gZXhwb3J0cy5DYWlwVG9rZW5JZFN0cnVjdCA9IGV4cG9ydHMuQ2FpcEFzc2V0UmVmZXJlbmNlU3RydWN0ID0gZXhwb3J0cy5DYWlwQXNzZXROYW1lc3BhY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBY2NvdW50QWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCA9IGV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9IGV4cG9ydHMuQ2FpcE5hbWVzcGFjZVN0cnVjdCA9IGV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QgPSBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVggPSBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9UT0tFTl9JRF9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BU1NFVF9SRUZFUkVOQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVggPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIi4vc3VwZXJzdHJ1Y3QuY2pzXCIpO1xuZXhwb3J0cy5DQUlQX0NIQUlOX0lEX1JFR0VYID0gL14oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSQvdTtcbmV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSAvXlstYS16MC05XXszLDh9JC91O1xuZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IC9eWy1fYS16QS1aMC05XXsxLDMyfSQvdTtcbmV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gL14oPzxjaGFpbklkPig/PG5hbWVzcGFjZT5bLWEtejAtOV17Myw4fSk6KD88cmVmZXJlbmNlPlstX2EtekEtWjAtOV17MSwzMn0pKTooPzxhY2NvdW50QWRkcmVzcz5bLS4lYS16QS1aMC05XXsxLDEyOH0pJC91O1xuZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IC9eWy0uJWEtekEtWjAtOV17MSwxMjh9JC91O1xuZXhwb3J0cy5DQUlQX0FTU0VUX05BTUVTUEFDRV9SRUdFWCA9IC9eWy1hLXowLTldezMsOH0kL3U7XG5leHBvcnRzLkNBSVBfQVNTRVRfUkVGRVJFTkNFX1JFR0VYID0gL15bLS4lYS16QS1aMC05XXsxLDEyOH0kL3U7XG5leHBvcnRzLkNBSVBfVE9LRU5fSURfUkVHRVggPSAvXlstLiVhLXpBLVowLTldezEsNzh9JC91O1xuZXhwb3J0cy5DQUlQX0FTU0VUX1RZUEVfUkVHRVggPSAvXig/PGNoYWluSWQ+KD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkpXFwvKD88YXNzZXROYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PGFzc2V0UmVmZXJlbmNlPlstLiVhLXpBLVowLTldezEsMTI4fSkkL3U7XG5leHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVggPSAvXig/PGNoYWluSWQ+KD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkpXFwvKD88YXNzZXROYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PGFzc2V0UmVmZXJlbmNlPlstLiVhLXpBLVowLTldezEsMTI4fSlcXC8oPzx0b2tlbklkPlstLiVhLXpBLVowLTldezEsNzh9KSQvdTtcbmNvbnN0IENBSVBfQVNTRVRfVFlQRV9PUl9JRF9SRUdFWCA9IC9eKD88Y2hhaW5JZD4oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSlcXC8oPzxhc3NldE5hbWVzcGFjZT5bLWEtejAtOV17Myw4fSk6KD88YXNzZXRSZWZlcmVuY2U+Wy0uJWEtekEtWjAtOV17MSwxMjh9KShcXC8oPzx0b2tlbklkPlstLiVhLXpBLVowLTldezEsNzh9KSk/JC91O1xuLyoqXG4gKiBBIENBSVAtMiBjaGFpbiBJRCwgaS5lLiwgYSBodW1hbi1yZWFkYWJsZSBuYW1lc3BhY2UgYW5kIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0cy5DYWlwQ2hhaW5JZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwQ2hhaW5JZCcsIGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0yIG5hbWVzcGFjZSwgaS5lLiwgdGhlIGZpcnN0IHBhcnQgb2YgYSBDQUlQIGNoYWluIElELlxuICovXG5leHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcE5hbWVzcGFjZScsIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMiByZWZlcmVuY2UsIGkuZS4sIHRoZSBzZWNvbmQgcGFydCBvZiBhIENBSVAgY2hhaW4gSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwUmVmZXJlbmNlJywgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xMCBhY2NvdW50IElELCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIG5hbWVzcGFjZSwgcmVmZXJlbmNlLCBhbmQgYWNjb3VudCBhZGRyZXNzLlxuICovXG5leHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFjY291bnRJZCcsIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYKTtcbi8qKlxuICogQSBDQUlQLTEwIGFjY291bnQgYWRkcmVzcywgaS5lLiwgdGhlIHRoaXJkIHBhcnQgb2YgdGhlIENBSVAgYWNjb3VudCBJRC5cbiAqL1xuZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFjY291bnRBZGRyZXNzJywgZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCBuYW1lc3BhY2UsIGkuZS4sIGEgbmFtZXNwYWNlIGRvbWFpbiBvZiBhbiBhc3NldC5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXROYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0TmFtZXNwYWNlJywgZXhwb3J0cy5DQUlQX0FTU0VUX05BTUVTUEFDRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCByZWZlcmVuY2UsIGkuZS4sIGFuIGlkZW50aWZpZXIgZm9yIGFuIGFzc2V0IHdpdGhpbiBhIGdpdmVuIG5hbWVzcGFjZS5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRSZWZlcmVuY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0UmVmZXJlbmNlJywgZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCB0b2tlbiBJRCwgaS5lLiwgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYW4gYWRkcmVzc2FibGUgYXNzZXQgb2YgYSBnaXZlbiB0eXBlXG4gKi9cbmV4cG9ydHMuQ2FpcFRva2VuSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcFRva2VuSWQnLCBleHBvcnRzLkNBSVBfVE9LRU5fSURfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMTkgYXNzZXQgdHlwZSBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRUeXBlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lUGF0dGVybikoJ0NhaXBBc3NldFR5cGUnLCBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xOSBhc3NldCBJRCBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcEFzc2V0SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmVQYXR0ZXJuKSgnQ2FpcEFzc2V0SWQnLCBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMTkgYXNzZXQgdHlwZSBvciBhc3NldCBJRCBpZGVudGlmaWVyLCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIHR5cGUgb2YgYXNzZXQgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0cy5DYWlwQXNzZXRUeXBlT3JJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZVBhdHRlcm4pKCdDYWlwQXNzZXRUeXBlT3JJZCcsIENBSVBfQVNTRVRfVFlQRV9PUl9JRF9SRUdFWCk7XG4vKiogS25vd24gQ0FJUCBuYW1lc3BhY2VzLiAqL1xudmFyIEtub3duQ2FpcE5hbWVzcGFjZTtcbihmdW5jdGlvbiAoS25vd25DYWlwTmFtZXNwYWNlKSB7XG4gICAgLyoqIEJJUC0xMjIgKEJpdGNvaW4pIGNvbXBhdGlibGUgY2hhaW5zLiAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIkJpcDEyMlwiXSA9IFwiYmlwMTIyXCI7XG4gICAgLyoqIFNvbGFuYSBjb21wYXRpYmxlIGNoYWlucyAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIlNvbGFuYVwiXSA9IFwic29sYW5hXCI7XG4gICAgLyoqIFRyb24gY29tcGF0aWJsZSBjaGFpbnMgKi9cbiAgICBLbm93bkNhaXBOYW1lc3BhY2VbXCJUcm9uXCJdID0gXCJ0cm9uXCI7XG4gICAgLyoqIEVJUC0xNTUgY29tcGF0aWJsZSBjaGFpbnMuICovXG4gICAgS25vd25DYWlwTmFtZXNwYWNlW1wiRWlwMTU1XCJdID0gXCJlaXAxNTVcIjtcbiAgICBLbm93bkNhaXBOYW1lc3BhY2VbXCJXYWxsZXRcIl0gPSBcIndhbGxldFwiO1xufSkoS25vd25DYWlwTmFtZXNwYWNlID0gZXhwb3J0cy5Lbm93bkNhaXBOYW1lc3BhY2UgfHwgKGV4cG9ydHMuS25vd25DYWlwTmFtZXNwYWNlID0ge30pKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBDaGFpbklkfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQ2hhaW5JZH0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcENoYWluSWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcENoYWluSWQgPSBpc0NhaXBDaGFpbklkO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcE5hbWVzcGFjZX0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcE5hbWVzcGFjZX0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcE5hbWVzcGFjZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcE5hbWVzcGFjZSA9IGlzQ2FpcE5hbWVzcGFjZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBSZWZlcmVuY2V9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBSZWZlcmVuY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBSZWZlcmVuY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfUkVGRVJFTkNFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBSZWZlcmVuY2UgPSBpc0NhaXBSZWZlcmVuY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudElkfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudElkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQWNjb3VudElkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX0FDQ09VTlRfSURfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGlzQ2FpcEFjY291bnRJZDtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudEFkZHJlc3N9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIENhaXBBY2NvdW50QWRkcmVzc30uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQWNjb3VudEFkZHJlc3MgPSBpc0NhaXBBY2NvdW50QWRkcmVzcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldE5hbWVzcGFjZX0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0TmFtZXNwYWNlfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQXNzZXROYW1lc3BhY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBBc3NldE5hbWVzcGFjZSA9IGlzQ2FpcEFzc2V0TmFtZXNwYWNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0UmVmZXJlbmNlfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQXNzZXRSZWZlcmVuY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBBc3NldFJlZmVyZW5jZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9BU1NFVF9SRUZFUkVOQ0VfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzQ2FpcEFzc2V0UmVmZXJlbmNlID0gaXNDYWlwQXNzZXRSZWZlcmVuY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwVG9rZW5JZH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcFRva2VuSWR9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBUb2tlbklkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZXhwb3J0cy5DQUlQX1RPS0VOX0lEX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0NhaXBUb2tlbklkID0gaXNDYWlwVG9rZW5JZDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldFR5cGV9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldFR5cGV9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBBc3NldFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQXNzZXRUeXBlID0gaXNDYWlwQXNzZXRUeXBlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFzc2V0SWR9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBBc3NldElkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQXNzZXRJZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cG9ydHMuQ0FJUF9BU1NFVF9JRF9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNDYWlwQXNzZXRJZCA9IGlzQ2FpcEFzc2V0SWQ7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0yIGNoYWluIElEIHRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lc3BhY2UgYW5kIHJlZmVyZW5jZS5cbiAqIFRoaXMgdmFsaWRhdGVzIHRoZSBDQUlQLTIgY2hhaW4gSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBDaGFpbklkIC0gVGhlIENBSVAtMiBjaGFpbiBJRCB0byB2YWxpZGF0ZSBhbmQgcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIENBSVAtMiBjaGFpbiBJRC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWlwQ2hhaW5JZChjYWlwQ2hhaW5JZCkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhwb3J0cy5DQUlQX0NIQUlOX0lEX1JFR0VYLmV4ZWMoY2FpcENoYWluSWQpO1xuICAgIGlmICghbWF0Y2g/Lmdyb3Vwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FJUCBjaGFpbiBJRC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZXNwYWNlOiBtYXRjaC5ncm91cHMubmFtZXNwYWNlLFxuICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQ2hhaW5JZCA9IHBhcnNlQ2FpcENoYWluSWQ7XG4vKipcbiAqIFBhcnNlIGFuIENBSVAtMTAgYWNjb3VudCBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhaW4gSUQsIHBhcnNlZCBjaGFpbiBJRCwgYW5kIGFjY291bnQgYWRkcmVzcy5cbiAqIFRoaXMgdmFsaWRhdGVzIHRoZSBDQUlQLTEwIGFjY291bnQgSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBBY2NvdW50SWQgLSBUaGUgQ0FJUC0xMCBhY2NvdW50IElEIHRvIHZhbGlkYXRlIGFuZCBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgQ0FJUC0xMCBhY2NvdW50IElELlxuICovXG5mdW5jdGlvbiBwYXJzZUNhaXBBY2NvdW50SWQoY2FpcEFjY291bnRJZCkge1xuICAgIGNvbnN0IG1hdGNoID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfSURfUkVHRVguZXhlYyhjYWlwQWNjb3VudElkKTtcbiAgICBpZiAoIW1hdGNoPy5ncm91cHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBSVAgYWNjb3VudCBJRC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogbWF0Y2guZ3JvdXBzLmFjY291bnRBZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBtYXRjaC5ncm91cHMuY2hhaW5JZCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLnJlZmVyZW5jZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUNhaXBBY2NvdW50SWQgPSBwYXJzZUNhaXBBY2NvdW50SWQ7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0xOSBhc3NldCB0eXBlIHRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGFpbiBJRCwgcGFyc2VkIGNoYWluIElELFxuICogYXNzZXQgbmFtZXNwYWNlLCBhbmQgYXNzZXQgcmVmZXJlbmNlXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIENBSVAtMTkgYXNzZXQgdHlwZSBiZWZvcmUgcGFyc2luZyBpdC5cbiAqXG4gKiBAcGFyYW0gY2FpcEFzc2V0VHlwZSAtIFRoZSBDQUlQLTE5IGFzc2V0IHR5cGUgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTE5IGFzc2V0IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FpcEFzc2V0VHlwZShjYWlwQXNzZXRUeXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHBvcnRzLkNBSVBfQVNTRVRfVFlQRV9SRUdFWC5leGVjKGNhaXBBc3NldFR5cGUpO1xuICAgIGlmICghbWF0Y2g/Lmdyb3Vwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FJUCBhc3NldCB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldE5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLmFzc2V0TmFtZXNwYWNlLFxuICAgICAgICBhc3NldFJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLmFzc2V0UmVmZXJlbmNlLFxuICAgICAgICBjaGFpbklkOiBtYXRjaC5ncm91cHMuY2hhaW5JZCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLnJlZmVyZW5jZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUNhaXBBc3NldFR5cGUgPSBwYXJzZUNhaXBBc3NldFR5cGU7XG4vKipcbiAqIFBhcnNlIGEgQ0FJUC0xOSBhc3NldCBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hhaW4gSUQsIHBhcnNlZCBjaGFpbiBJRCxcbiAqIGFzc2V0IG5hbWVzcGFjZSwgYXNzZXQgcmVmZXJlbmNlLCBhbmQgdG9rZW4gSUQuXG4gKlxuICogVGhpcyB2YWxpZGF0ZXMgdGhlIENBSVAtMTkgYXNzZXQgSUQgYmVmb3JlIHBhcnNpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNhaXBBc3NldElkIC0gVGhlIENBSVAtMTkgYXNzZXQgSUQgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTE5IGFzc2V0IElELlxuICovXG5mdW5jdGlvbiBwYXJzZUNhaXBBc3NldElkKGNhaXBBc3NldElkKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHBvcnRzLkNBSVBfQVNTRVRfSURfUkVHRVguZXhlYyhjYWlwQXNzZXRJZCk7XG4gICAgaWYgKCFtYXRjaD8uZ3JvdXBzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDQUlQIGFzc2V0IElELicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldE5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLmFzc2V0TmFtZXNwYWNlLFxuICAgICAgICBhc3NldFJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLmFzc2V0UmVmZXJlbmNlLFxuICAgICAgICB0b2tlbklkOiBtYXRjaC5ncm91cHMudG9rZW5JZCxcbiAgICAgICAgY2hhaW5JZDogbWF0Y2guZ3JvdXBzLmNoYWluSWQsXG4gICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICBuYW1lc3BhY2U6IG1hdGNoLmdyb3Vwcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQXNzZXRJZCA9IHBhcnNlQ2FpcEFzc2V0SWQ7XG4vKipcbiAqIENoYWluIElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5BZ25vc3RpYy9DQUlQcy9ibG9iL21haW4vQ0FJUHMvY2FpcC0yLm1kfS5cbiAqXG4gKiBJdCBkZWZpbmVzIGEgd2F5IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFueSBibG9ja2NoYWluIGluIGEgaHVtYW4tcmVhZGFibGVcbiAqIHdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZXNwYWNlIC0gVGhlIHN0YW5kYXJkIChlY29zeXN0ZW0pIG9mIHNpbWlsYXIgYmxvY2tjaGFpbnMuXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gSWRlbnRpZnkgb2YgYSBibG9ja2NoYWluIHdpdGhpbiBhIGdpdmVuIG5hbWVzcGFjZS5cbiAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfVxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBpbnB1dHMgZG9lcyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMlxuICogc3ludGF4IHNwZWNpZmljYXRpb25cbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5BZ25vc3RpYy9DQUlQcy9ibG9iL21haW4vQ0FJUHMvY2FpcC0yLm1kI3N5bnRheH0uXG4gKiBAcmV0dXJucyBBIENBSVAgY2hhaW4gSUQuXG4gKi9cbmZ1bmN0aW9uIHRvQ2FpcENoYWluSWQobmFtZXNwYWNlLCByZWZlcmVuY2UpIHtcbiAgICBpZiAoIWlzQ2FpcE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcIm5hbWVzcGFjZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBSZWZlcmVuY2UocmVmZXJlbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJyZWZlcmVuY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfUkVGRVJFTkNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtuYW1lc3BhY2V9OiR7cmVmZXJlbmNlfWA7XG59XG5leHBvcnRzLnRvQ2FpcENoYWluSWQgPSB0b0NhaXBDaGFpbklkO1xuLyoqXG4gKiBBY2NvdW50IElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTEwXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTAubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYWNjb3VudCBpbiBhIGh1bWFuLXJlYWRhYmxlXG4gKiB3YXkuXG4gKlxuICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBzdGFuZGFyZCAoZWNvc3lzdGVtKSBvZiBzaW1pbGFyIGJsb2NrY2hhaW5zLlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIElkZW50aXR5IG9mIGEgYmxvY2tjaGFpbiB3aXRoaW4gYSBnaXZlbiBuYW1lc3BhY2UuXG4gKiBAcGFyYW0gYWNjb3VudEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYmxvY2tjaGFpbiBhY2NvdW50LlxuICogQHRocm93cyB7QGxpbmsgRXJyb3J9XG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGlucHV0cyBkbyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMTBcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTAubWQjc3ludGF4fS5cbiAqIEByZXR1cm5zIEEgQ0FJUCBhY2NvdW50IElELlxuICovXG5mdW5jdGlvbiB0b0NhaXBBY2NvdW50SWQobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgaWYgKCFpc0NhaXBOYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJuYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwUmVmZXJlbmNlKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwicmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcEFjY291bnRBZGRyZXNzKGFjY291bnRBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJhY2NvdW50QWRkcmVzc1wiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWVzcGFjZX06JHtyZWZlcmVuY2V9OiR7YWNjb3VudEFkZHJlc3N9YDtcbn1cbmV4cG9ydHMudG9DYWlwQWNjb3VudElkID0gdG9DYWlwQWNjb3VudElkO1xuLyoqXG4gKiBBc3NldCBUeXBlIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTE5XG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYXNzZXQgaW4gYSBodW1hbi1yZWFkYWJsZVxuICogd2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgc3RhbmRhcmQgKGVjb3N5c3RlbSkgb2Ygc2ltaWxhciBibG9ja2NoYWlucy5cbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBJZGVudGl0eSBvZiBhIGJsb2NrY2hhaW4gd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIGFzc2V0TmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSBkb21haW4gb2YgYW4gYXNzZXQuXG4gKiBAcGFyYW0gYXNzZXRSZWZlcmVuY2UgLSBUaGUgaWRlbnRpdHkgb2YgYW4gYXNzZXQgd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHRocm93cyB7QGxpbmsgRXJyb3J9XG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGlucHV0cyBkbyBub3QgY29tcGx5IHdpdGggdGhlIENBSVAtMTlcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWQjc3ludGF4fS5cbiAqIEByZXR1cm5zIEEgQ0FJUCBhc3NldCB0eXBlLlxuICovXG5mdW5jdGlvbiB0b0NhaXBBc3NldFR5cGUobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFzc2V0TmFtZXNwYWNlLCBhc3NldFJlZmVyZW5jZSkge1xuICAgIGlmICghaXNDYWlwTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwibmFtZXNwYWNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX05BTUVTUEFDRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFJlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJlZmVyZW5jZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBBc3NldE5hbWVzcGFjZShhc3NldE5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiYXNzZXROYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwQXNzZXRSZWZlcmVuY2UoYXNzZXRSZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImFzc2V0UmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX0vJHthc3NldE5hbWVzcGFjZX06JHthc3NldFJlZmVyZW5jZX1gO1xufVxuZXhwb3J0cy50b0NhaXBBc3NldFR5cGUgPSB0b0NhaXBBc3NldFR5cGU7XG4vKipcbiAqIEFzc2V0IElEIGFzIGRlZmluZWQgcGVyIHRoZSBDQUlQLTE5XG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMTkubWR9LlxuICpcbiAqIEl0IGRlZmluZXMgYSB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW55IGJsb2NrY2hhaW4gYXNzZXQgaW4gYSBodW1hbi1yZWFkYWJsZVxuICogd2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgc3RhbmRhcmQgKGVjb3N5c3RlbSkgb2Ygc2ltaWxhciBibG9ja2NoYWlucy5cbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBJZGVudGl0eSBvZiBhIGJsb2NrY2hhaW4gd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIGFzc2V0TmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSBkb21haW4gb2YgYW4gYXNzZXQuXG4gKiBAcGFyYW0gYXNzZXRSZWZlcmVuY2UgLSBUaGUgaWRlbnRpdHkgb2YgYW4gYXNzZXQgd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlLlxuICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGFuIGFkZHJlc3NhYmxlIGFzc2V0IG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIEB0aHJvd3Mge0BsaW5rIEVycm9yfVxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBpbnB1dHMgZG8gbm90IGNvbXBseSB3aXRoIHRoZSBDQUlQLTE5XG4gKiBzeW50YXggc3BlY2lmaWNhdGlvblxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9DaGFpbkFnbm9zdGljL0NBSVBzL2Jsb2IvbWFpbi9DQUlQcy9jYWlwLTE5Lm1kI3N5bnRheH0uXG4gKiBAcmV0dXJucyBBIENBSVAgYXNzZXQgSUQuXG4gKi9cbmZ1bmN0aW9uIHRvQ2FpcEFzc2V0SWQobmFtZXNwYWNlLCByZWZlcmVuY2UsIGFzc2V0TmFtZXNwYWNlLCBhc3NldFJlZmVyZW5jZSwgdG9rZW5JZCkge1xuICAgIGlmICghaXNDYWlwTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwibmFtZXNwYWNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX05BTUVTUEFDRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFJlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJlZmVyZW5jZVwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVgudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0NhaXBBc3NldE5hbWVzcGFjZShhc3NldE5hbWVzcGFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiYXNzZXROYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfQVNTRVRfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwQXNzZXRSZWZlcmVuY2UoYXNzZXRSZWZlcmVuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImFzc2V0UmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX0FTU0VUX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBpZiAoIWlzQ2FpcFRva2VuSWQodG9rZW5JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidG9rZW5JZFwiLCBtdXN0IG1hdGNoOiAke2V4cG9ydHMuQ0FJUF9UT0tFTl9JRF9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX0vJHthc3NldE5hbWVzcGFjZX06JHthc3NldFJlZmVyZW5jZX0vJHt0b2tlbklkfWA7XG59XG5leHBvcnRzLnRvQ2FpcEFzc2V0SWQgPSB0b0NhaXBBc3NldElkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FpcC10eXBlcy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/caip-types.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/checksum.cjs":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/checksum.cjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst base64_1 = __webpack_require__(/*! ./base64.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/base64.cjs\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);\n//# sourceMappingURL=checksum.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsc0JBQXNCLG1CQUFPLENBQUMsMklBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHdIQUFjO0FBQ3ZDLHNCQUFzQiwrRUFBK0UsdUJBQXVCO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uY2pzPzVkMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/checksum.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/coercers.cjs":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/coercers.cjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs\");\nconst NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nfunction createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nfunction createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nfunction createBytes(value) {\n    if (typeof value === 'string' && value.toLowerCase() === '0x') {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nfunction createHex(value) {\n    if ((value instanceof Uint8Array && value.length === 0) ||\n        (typeof value === 'string' && value.toLowerCase() === '0x')) {\n        return '0x';\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createHex = createHex;\n//# sourceMappingURL=coercers.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDckYsc0JBQXNCLG1CQUFPLENBQUMsMklBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHdIQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHNIQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrSEFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsTUFBTTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2VyY2Vycy5janM/YWQzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/coercers.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/collections.cjs":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/collections.cjs ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    constructor(entries) {\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0\n            ? ` ${[...this.entries()]\n                .map(([key, value]) => `${String(key)} => ${String(value)}`)\n                .join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    constructor(values) {\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0\n            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n//# sourceMappingURL=collections.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckM7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVLEdBQUcsRUFBRTtBQUMzQyxrQkFBa0I7QUFDbEIsMENBQTBDLGFBQWEsS0FBSyxjQUFjO0FBQzFFLDZCQUE2QjtBQUM3QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsR0FBRyxFQUFFO0FBQzNDLGtCQUFrQiwrREFBK0Q7QUFDakYsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmNqcz9jOTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/collections.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/encryption-types.cjs":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/encryption-types.cjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=encryption-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5janM/YjJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/encryption-types.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.cjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.cjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapError = exports.getErrorMessage = exports.isErrorWithStack = exports.isErrorWithMessage = exports.isErrorWithCode = void 0;\nconst pony_cause_1 = __webpack_require__(/*! pony-cause */ \"(ssr)/../../node_modules/.pnpm/pony-cause@2.1.11/node_modules/pony-cause/index.js\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0, misc_1.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\nexports.isErrorWithCode = isErrorWithCode;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\nexports.isErrorWithMessage = isErrorWithMessage;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\nexports.isErrorWithStack = isErrorWithStack;\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0, misc_1.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\nexports.getErrorMessage = getErrorMessage;\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause_1.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\nexports.wrapError = wrapError;\n//# sourceMappingURL=errors.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Vycm9ycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCO0FBQzdILHFCQUFxQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxvSEFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCLElBQUksUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMuY2pzP2IyOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gZXhwb3J0cy5pc0Vycm9yV2l0aFN0YWNrID0gZXhwb3J0cy5pc0Vycm9yV2l0aE1lc3NhZ2UgPSBleHBvcnRzLmlzRXJyb3JXaXRoQ29kZSA9IHZvaWQgMDtcbmNvbnN0IHBvbnlfY2F1c2VfMSA9IHJlcXVpcmUoXCJwb255LWNhdXNlXCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzYy5janNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICogRm9yIGVycm9ycyBnZW5lcmF0ZWQgdmlhIGBmcy5wcm9taXNlc2AsIGBlcnJvciBpbnN0YW5jZW9mIEVycm9yYCB3b24ndCB3b3JrLFxuICogc28gd2UgaGF2ZSB0byBjb21lIHVwIHdpdGggYW5vdGhlciB3YXkgb2YgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICgoMCwgbWlzY18xLmlzT2JqZWN0KShlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gJ0Vycm9yJykpO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgY29kZWAgcHJvcGVydHkgc3VjaCBhcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IE5vZGUgdGhyb3dzIGZvciBmaWxlc3lzdGVtXG4gKiBvcGVyYXRpb25zLCBldGMuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuZXhwb3J0cy5pc0Vycm9yV2l0aENvZGUgPSBpc0Vycm9yV2l0aENvZGU7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzRXJyb3JXaXRoTWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aFN0YWNrKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNFcnJvcldpdGhTdGFjayA9IGlzRXJyb3JXaXRoU3RhY2s7XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGlmIChpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCBtaXNjXzEuaXNOdWxsT3JVbmRlZmluZWQpKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoZXJyb3IpO1xufVxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBlcnJvciBvYmplY3QsIGxpbmtpbmcgaXQgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHZpYSB0aGUgYGNhdXNlYFxuICogcHJvcGVydHkgaWYgaXQgaXMgYW4gRXJyb3IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgdG8gcmVmcmFtZSBlcnJvciBtZXNzYWdlcyBpbiBnZW5lcmFsLCBidXQgaXNcbiAqIF9jcml0aWNhbF8gd2hlbiBpbnRlcmFjdGluZyB3aXRoIGFueSBvZiBOb2RlJ3MgZmlsZXN5c3RlbSBmdW5jdGlvbnMgYXNcbiAqIHByb3ZpZGVkIHZpYSBgZnMucHJvbWlzZXNgLCBiZWNhdXNlIHRoZXNlIGRvIG5vdCBwcm9kdWNlIHN0YWNrIHRyYWNlcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYW4gSS9PIGVycm9yIChzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzA5NDQ+KS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxFcnJvciAtIFRoZSBlcnJvciB0byBiZSB3cmFwcGVkIChzb21ldGhpbmcgdGhyb3dhYmxlKS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGRlc2lyZWQgbWVzc2FnZSBvZiB0aGUgbmV3IGVycm9yLlxuICogQHJldHVybnMgQSBuZXcgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBwb255X2NhdXNlXzEuRXJyb3JXaXRoQ2F1c2UobWVzc2FnZSwgeyBjYXVzZTogb3JpZ2luYWxFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFcnJvcldpdGhDb2RlKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gb3JpZ2luYWxFcnJvci5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGAke1N0cmluZyhvcmlnaW5hbEVycm9yKX06ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcob3JpZ2luYWxFcnJvcikpO1xufVxuZXhwb3J0cy53cmFwRXJyb3IgPSB3cmFwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.remove0x = exports.add0x = exports.isValidHexAddress = exports.isValidHexAddressUnmemoized = exports.isValidChecksumAddress = exports.isValidChecksumAddressUnmemoized = exports.getChecksumAddress = exports.getChecksumAddressUnmemoized = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isHexChecksumAddress = exports.isHexAddress = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha3.js\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"(ssr)/../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\n// Use native regexes instead of superstruct for maximum performance.\n// Pre-compiled regex for maximum performance - avoids recompilation on each call\nconst HEX_REGEX = /^(?:0x)?[0-9a-f]+$/iu;\nconst STRICT_HEX_REGEX = /^0x[0-9a-f]+$/iu;\nconst HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/u;\nconst HEX_CHECKSUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/u;\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_REGEX);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), STRICT_HEX_REGEX);\nexports.HexAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_ADDRESS_REGEX);\nexports.HexChecksumAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), HEX_CHECKSUM_ADDRESS_REGEX);\nconst isString = (value) => typeof value === 'string';\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n    return isString(value) && HEX_REGEX.test(value);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n    return isString(value) && STRICT_HEX_REGEX.test(value);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Check if a string is a valid hex address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex address.\n */\nfunction isHexAddress(value) {\n    return isString(value) && HEX_ADDRESS_REGEX.test(value);\n}\nexports.isHexAddress = isHexAddress;\n/**\n * Check if a string is a valid hex checksum address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex checksum address.\n */\nfunction isHexChecksumAddress(value) {\n    return isString(value) && HEX_CHECKSUM_ADDRESS_REGEX.test(value);\n}\nexports.isHexChecksumAddress = isHexChecksumAddress;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This is the unmemoized version, primarily used for testing.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nfunction getChecksumAddressUnmemoized(hexAddress) {\n    (0, assert_1.assert)(isHexChecksumAddress(hexAddress), 'Invalid hex address.');\n    const address = remove0x(hexAddress).toLowerCase();\n    const hashBytes = (0, sha3_1.keccak_256)(address);\n    const { length } = address;\n    const result = new Array(length); // Pre-allocate array\n    for (let i = 0; i < length; i++) {\n        /* eslint-disable no-bitwise */\n        const byteIndex = i >> 1; // Faster than Math.floor(i / 2)\n        const nibbleIndex = i & 1; // Faster than i % 2\n        const byte = hashBytes[byteIndex];\n        const nibble = nibbleIndex === 0 ? byte >> 4 : byte & 0x0f;\n        /* eslint-enable no-bitwise */\n        result[i] = nibble >= 8 ? address[i].toUpperCase() : address[i];\n    }\n    return `0x${result.join('')}`;\n}\nexports.getChecksumAddressUnmemoized = getChecksumAddressUnmemoized;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This function is memoized for performance.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexports.getChecksumAddress = (0, lodash_1.memoize)(getChecksumAddressUnmemoized);\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nfunction isValidChecksumAddressUnmemoized(possibleChecksum) {\n    if (!isHexChecksumAddress(possibleChecksum)) {\n        return false;\n    }\n    return (0, exports.getChecksumAddress)(possibleChecksum) === possibleChecksum;\n}\nexports.isValidChecksumAddressUnmemoized = isValidChecksumAddressUnmemoized;\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexports.isValidChecksumAddress = (0, lodash_1.memoize)(isValidChecksumAddressUnmemoized);\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nfunction isValidHexAddressUnmemoized(possibleAddress) {\n    return (isHexAddress(possibleAddress) || (0, exports.isValidChecksumAddress)(possibleAddress));\n}\nexports.isValidHexAddressUnmemoized = isValidHexAddressUnmemoized;\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexports.isValidHexAddress = (0, lodash_1.memoize)(isValidHexAddressUnmemoized);\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x;\n//# sourceMappingURL=hex.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLHlCQUF5QixHQUFHLG1DQUFtQyxHQUFHLDhCQUE4QixHQUFHLHdDQUF3QyxHQUFHLDBCQUEwQixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQjtBQUNwZ0Isc0JBQXNCLG1CQUFPLENBQUMsMklBQXVCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxpSEFBb0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMkZBQVE7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsd0hBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQyxtREFBbUQsR0FBRztBQUN0RCxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHNDQUFzQztBQUN0QyxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguY2pzP2UzMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZTB4ID0gZXhwb3J0cy5hZGQweCA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzVW5tZW1vaXplZCA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQgPSBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzVW5tZW1vaXplZCA9IGV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNIZXhBZGRyZXNzID0gZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IHNoYTNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTNcIik7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vLyBVc2UgbmF0aXZlIHJlZ2V4ZXMgaW5zdGVhZCBvZiBzdXBlcnN0cnVjdCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS5cbi8vIFByZS1jb21waWxlZCByZWdleCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZSAtIGF2b2lkcyByZWNvbXBpbGF0aW9uIG9uIGVhY2ggY2FsbFxuY29uc3QgSEVYX1JFR0VYID0gL14oPzoweCk/WzAtOWEtZl0rJC9pdTtcbmNvbnN0IFNUUklDVF9IRVhfUkVHRVggPSAvXjB4WzAtOWEtZl0rJC9pdTtcbmNvbnN0IEhFWF9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZdezQwfSQvdTtcbmNvbnN0IEhFWF9DSEVDS1NVTV9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZBLUZdezQwfSQvdTtcbmV4cG9ydHMuSGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBIRVhfUkVHRVgpO1xuZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIFNUUklDVF9IRVhfUkVHRVgpO1xuZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBIRVhfQUREUkVTU19SRUdFWCk7XG5leHBvcnRzLkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgSEVYX0NIRUNLU1VNX0FERFJFU1NfUkVHRVgpO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiBIRVhfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgU1RSSUNUX0hFWF9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc0hleEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIEhFWF9BRERSRVNTX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0hleEFkZHJlc3MgPSBpc0hleEFkZHJlc3M7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggY2hlY2tzdW0gYWRkcmVzcy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhDaGVja3N1bUFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIEhFWF9DSEVDS1NVTV9BRERSRVNTX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZXhwb3J0cy5pc0hleENoZWNrc3VtQWRkcmVzcyA9IGlzSGV4Q2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBpcyB0aGUgdW5tZW1vaXplZCB2ZXJzaW9uLCBwcmltYXJpbHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gaGV4QWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBlbmNvZGVkIGFjY29yZGluZyB0byBFUkMtNTUuXG4gKiBAc2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzVW5tZW1vaXplZChoZXhBZGRyZXNzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNIZXhDaGVja3N1bUFkZHJlc3MoaGV4QWRkcmVzcyksICdJbnZhbGlkIGhleCBhZGRyZXNzLicpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSByZW1vdmUweChoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc2hCeXRlcyA9ICgwLCBzaGEzXzEua2VjY2FrXzI1NikoYWRkcmVzcyk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFkZHJlc3M7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7IC8vIFByZS1hbGxvY2F0ZSBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICAgICBjb25zdCBieXRlSW5kZXggPSBpID4+IDE7IC8vIEZhc3RlciB0aGFuIE1hdGguZmxvb3IoaSAvIDIpXG4gICAgICAgIGNvbnN0IG5pYmJsZUluZGV4ID0gaSAmIDE7IC8vIEZhc3RlciB0aGFuIGkgJSAyXG4gICAgICAgIGNvbnN0IGJ5dGUgPSBoYXNoQnl0ZXNbYnl0ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmliYmxlID0gbmliYmxlSW5kZXggPT09IDAgPyBieXRlID4+IDQgOiBieXRlICYgMHgwZjtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4gICAgICAgIHJlc3VsdFtpXSA9IG5pYmJsZSA+PSA4ID8gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpIDogYWRkcmVzc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7cmVzdWx0LmpvaW4oJycpfWA7XG59XG5leHBvcnRzLmdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQgPSBnZXRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkO1xuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBtZW1vaXplZCBmb3IgcGVyZm9ybWFuY2UuXG4gKlxuICogQHBhcmFtIGhleEFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3MgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGFkZHJlc3MgZW5jb2RlZCBhY2NvcmRpbmcgdG8gRVJDLTU1LlxuICogQHNlZSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1XG4gKi9cbmV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzID0gKDAsIGxvZGFzaF8xLm1lbW9pemUpKGdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQpO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgaGV4IHN0cmluZyBpcyBhIHZhbGlkIEVSQy01NSBtaXhlZC1jYXNlXG4gKiBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUNoZWNrc3VtIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkKHBvc3NpYmxlQ2hlY2tzdW0pIHtcbiAgICBpZiAoIWlzSGV4Q2hlY2tzdW1BZGRyZXNzKHBvc3NpYmxlQ2hlY2tzdW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcykocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQ7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIHBhc3NlZCBoZXggc3RyaW5nIGlzIGEgdmFsaWQgRVJDLTU1IG1peGVkLWNhc2VcbiAqIGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQ2hlY2tzdW0gLSBUaGUgaGV4IGFkZHJlc3MgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgY2hlY2tzdW0gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gKDAsIGxvZGFzaF8xLm1lbW9pemUpKGlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkKTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzc1VubWVtb2l6ZWQocG9zc2libGVBZGRyZXNzKSB7XG4gICAgcmV0dXJuIChpc0hleEFkZHJlc3MocG9zc2libGVBZGRyZXNzKSB8fCAoMCwgZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzKShwb3NzaWJsZUFkZHJlc3MpKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkID0gaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgcHJlZml4ZWQgaGV4IHN0cmluZyBpcyBhbiBhbGwtbG93ZXJjYXNlXG4gKiBoZXggYWRkcmVzcywgb3IgYSB2YWxpZCBtaXhlZC1jYXNlIGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIGlucHV0IGlzIGEgdmFsaWQgaGV4IGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSAoMCwgbG9kYXNoXzEubWVtb2l6ZSkoaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkKTtcbi8qKlxuICogQWRkIHRoZSBgMHhgLXByZWZpeCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGhhcyB0aGVcbiAqIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBhZGQgdGhlIHByZWZpeCB0by5cbiAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZDB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICAgIH1cbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWx9YDtcbn1cbmV4cG9ydHMuYWRkMHggPSBhZGQweDtcbi8qKlxuICogUmVtb3ZlIHRoZSBgMHhgLXByZWZpeCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGRvZXNuJ3QgaGF2ZVxuICogdGhlIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHJldHVybnMgVGhlIHVuLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/index.cjs":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/index.cjs ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unitMap = exports.getValueOfUnit = exports.numberToString = exports.fromWei = exports.toWei = exports.remove0x = exports.add0x = exports.isValidChecksumAddress = exports.getChecksumAddress = exports.isValidHexAddress = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isHexChecksumAddress = exports.isHexAddress = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\n__exportStar(__webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base64.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/base64.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./caip-types.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/caip-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/checksum.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/coercers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./collections.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/collections.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/encryption-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./errors.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.cjs\"), exports);\nvar hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs\");\nObject.defineProperty(exports, \"HexStruct\", ({ enumerable: true, get: function () { return hex_1.HexStruct; } }));\nObject.defineProperty(exports, \"StrictHexStruct\", ({ enumerable: true, get: function () { return hex_1.StrictHexStruct; } }));\nObject.defineProperty(exports, \"HexAddressStruct\", ({ enumerable: true, get: function () { return hex_1.HexAddressStruct; } }));\nObject.defineProperty(exports, \"HexChecksumAddressStruct\", ({ enumerable: true, get: function () { return hex_1.HexChecksumAddressStruct; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return hex_1.isHexString; } }));\nObject.defineProperty(exports, \"isStrictHexString\", ({ enumerable: true, get: function () { return hex_1.isStrictHexString; } }));\nObject.defineProperty(exports, \"isHexAddress\", ({ enumerable: true, get: function () { return hex_1.isHexAddress; } }));\nObject.defineProperty(exports, \"isHexChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.isHexChecksumAddress; } }));\nObject.defineProperty(exports, \"assertIsHexString\", ({ enumerable: true, get: function () { return hex_1.assertIsHexString; } }));\nObject.defineProperty(exports, \"assertIsStrictHexString\", ({ enumerable: true, get: function () { return hex_1.assertIsStrictHexString; } }));\nObject.defineProperty(exports, \"isValidHexAddress\", ({ enumerable: true, get: function () { return hex_1.isValidHexAddress; } }));\nObject.defineProperty(exports, \"getChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.getChecksumAddress; } }));\nObject.defineProperty(exports, \"isValidChecksumAddress\", ({ enumerable: true, get: function () { return hex_1.isValidChecksumAddress; } }));\nObject.defineProperty(exports, \"add0x\", ({ enumerable: true, get: function () { return hex_1.add0x; } }));\nObject.defineProperty(exports, \"remove0x\", ({ enumerable: true, get: function () { return hex_1.remove0x; } }));\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/keyring.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./logging.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/logging.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./misc.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./number.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/number.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/opaque.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./promise.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/promise.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./superstruct.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/superstruct.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./time.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/time.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/transaction-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./versions.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/versions.cjs\"), exports);\nvar unitsConversion_1 = __webpack_require__(/*! ./unitsConversion.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/unitsConversion.cjs\");\nObject.defineProperty(exports, \"toWei\", ({ enumerable: true, get: function () { return unitsConversion_1.toWei; } }));\nObject.defineProperty(exports, \"fromWei\", ({ enumerable: true, get: function () { return unitsConversion_1.fromWei; } }));\nObject.defineProperty(exports, \"numberToString\", ({ enumerable: true, get: function () { return unitsConversion_1.numberToString; } }));\nObject.defineProperty(exports, \"getValueOfUnit\", ({ enumerable: true, get: function () { return unitsConversion_1.getValueOfUnit; } }));\nObject.defineProperty(exports, \"unitMap\", ({ enumerable: true, get: function () { return unitsConversion_1.unitMap; } }));\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcseUJBQXlCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCO0FBQ2xmLGFBQWEsbUJBQU8sQ0FBQyx3SEFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsd0hBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHNIQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxnSUFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDRIQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsNEhBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxrSUFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLDRJQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsd0hBQWM7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLGtIQUFXO0FBQy9CLDZDQUE0QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMvRyxtREFBa0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDM0gsb0RBQW1ELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzdILDREQUEyRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUM3SSwrQ0FBOEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDbkgscURBQW9ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQy9ILGdEQUErQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNySCx3REFBdUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDckkscURBQW9ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQy9ILDJEQUEwRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUMzSSxxREFBb0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDL0gsc0RBQXFELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ2pJLDBEQUF5RCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN6SSx5Q0FBd0MsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdkcsNENBQTJDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQzdHLGFBQWEsbUJBQU8sQ0FBQyxvSEFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsMEhBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDBIQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxvSEFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsd0hBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHdIQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywwSEFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsa0lBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxvSEFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsOElBQXlCO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyw0SEFBZ0I7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsMElBQXVCO0FBQ3ZELHlDQUF3QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUNuSCwyQ0FBMEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDdkgsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSwyQ0FBMEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5janM/MDk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bml0TWFwID0gZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGV4cG9ydHMubnVtYmVyVG9TdHJpbmcgPSBleHBvcnRzLmZyb21XZWkgPSBleHBvcnRzLnRvV2VpID0gZXhwb3J0cy5yZW1vdmUweCA9IGV4cG9ydHMuYWRkMHggPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzSGV4QWRkcmVzcyA9IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5IZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLkhleEFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLlN0cmljdEhleFN0cnVjdCA9IGV4cG9ydHMuSGV4U3RydWN0ID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FpcC10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoZWNrc3VtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2xsZWN0aW9ucy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VuY3J5cHRpb24tdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnMuY2pzXCIpLCBleHBvcnRzKTtcbnZhciBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIZXhTdHJ1Y3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLkhleFN0cnVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmljdEhleFN0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuU3RyaWN0SGV4U3RydWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGV4QWRkcmVzc1N0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuSGV4QWRkcmVzc1N0cnVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzSGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzU3RyaWN0SGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZXhfMS5pc0hleEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleENoZWNrc3VtQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuaXNIZXhDaGVja3N1bUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRJc0hleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRJc1N0cmljdEhleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkSGV4QWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuaXNWYWxpZEhleEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGVja3N1bUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmdldENoZWNrc3VtQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRDaGVja3N1bUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleF8xLmlzVmFsaWRDaGVja3N1bUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGQweFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEuYWRkMHg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmUweFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4XzEucmVtb3ZlMHg7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleXJpbmcuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWlzYy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlci5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wYXF1ZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb21pc2UuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdXBlcnN0cnVjdC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RpbWUuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlcnNpb25zLmNqc1wiKSwgZXhwb3J0cyk7XG52YXIgdW5pdHNDb252ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi91bml0c0NvbnZlcnNpb24uY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9XZWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzQ29udmVyc2lvbl8xLnRvV2VpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVdlaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNDb252ZXJzaW9uXzEuZnJvbVdlaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm51bWJlclRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c0NvbnZlcnNpb25fMS5udW1iZXJUb1N0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFZhbHVlT2ZVbml0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c0NvbnZlcnNpb25fMS5nZXRWYWx1ZU9mVW5pdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaXRNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzQ29udmVyc2lvbl8xLnVuaXRNYXA7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/json.cjs":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/json.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.getSafeJson = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = exports.exactOptional = exports.object = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nconst object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\n(0, superstruct_1.object)(schema);\nexports.object = object;\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return (0, misc_1.hasProperty)(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nfunction exactOptional(struct) {\n    return new superstruct_1.Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\nexports.exactOptional = exactOptional;\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json) {\n    if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n        return true;\n    }\n    if (typeof json === 'number' && Number.isFinite(json)) {\n        return true;\n    }\n    if (typeof json === 'object') {\n        let every = true;\n        if (Array.isArray(json)) {\n            // Ignoring linting error since for-of is significantly slower than a normal for-loop\n            // and performance is important in this specific function.\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < json.length; i++) {\n                if (!validateJson(json[i])) {\n                    every = false;\n                    break;\n                }\n            }\n            return every;\n        }\n        const entries = Object.entries(json);\n        // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n        // and performance is important in this specific function.\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < entries.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {\n                every = false;\n                break;\n            }\n        }\n        return every;\n    }\n    return false;\n}\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexports.UnsafeJsonStruct = (0, superstruct_1.define)('JSON', (json) => validateJson(json));\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexports.JsonStruct = (0, superstruct_1.coerce)(exports.UnsafeJsonStruct, (0, superstruct_1.refine)((0, superstruct_1.any)(), 'JSON', (value) => (0, superstruct_1.is)(value, exports.UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n    // Strip __proto__ and constructor properties to prevent prototype pollution.\n    if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n    }\n    return propValue;\n})));\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexports.isValidJson = isValidJson;\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nfunction getSafeJson(value) {\n    return (0, superstruct_1.create)(value, exports.JsonStruct);\n}\nexports.getSafeJson = getSafeJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */\nexports.jsonrpc2 = '2.0';\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));\nexports.JsonRpcErrorStruct = (0, exports.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: exactOptional(exports.JsonStruct),\n    stack: exactOptional((0, superstruct_1.string)()),\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]);\nexports.JsonRpcRequestStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\nexports.JsonRpcNotificationStruct = (0, exports.object)({\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),\n});\nexports.JsonRpcSuccessStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct,\n});\nexports.JsonRpcFailureStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct,\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;\n//# sourceMappingURL=json.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLHNDQUFzQyxHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLG1DQUFtQyxHQUFHLDZCQUE2QixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLDRCQUE0QixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixHQUFHLGNBQWM7QUFDbjhCLHNCQUFzQixtQkFBTyxDQUFDLDJJQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3SEFBYztBQUN2QyxlQUFlLG1CQUFPLENBQUMsb0hBQVk7QUFDbkM7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLmNqcz9iMjk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuZ2V0SnNvblNpemUgPSBleHBvcnRzLmdldFNhZmVKc29uID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IGV4cG9ydHMuZXhhY3RPcHRpb25hbCA9IGV4cG9ydHMub2JqZWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjLmNqc1wiKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgb2JqZWN0LCB3aXRoIHN1cHBvcnQgZm9yXG4gKiB7QGxpbmsgZXhhY3RPcHRpb25hbH0gdHlwZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBleGFjdE9wdGlvbmFsYCBhbmQgYG9iamVjdGAgZnJvbSBgQG1ldGFtYXNrL3N1cGVyc3RydWN0QD49My4yLjBgIGluc3RlYWQuXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBvZiB0aGUgb2JqZWN0LlxuICogQHJldHVybnMgQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuY29uc3Qgb2JqZWN0ID0gKHNjaGVtYSkgPT4gXG4vLyBUaGUgdHlwZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBhIHJlZ3VsYXIgb2JqZWN0IHN0cnVjdCwgYmVjYXVzZSB3ZVxuLy8gd2FudCB0byBtYWtlIHByb3BlcnRpZXMgd2l0aCBgdW5kZWZpbmVkYCBpbiB0aGVpciB0eXBlIG9wdGlvbmFsLCBidXQgbm90XG4vLyBgdW5kZWZpbmVkYCBpdHNlbGYuIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIGEgdHlwZSBjYXN0LlxuKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KShzY2hlbWEpO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG4vKipcbiAqIENoZWNrIHRoZSBsYXN0IGZpZWxkIG9mIGEgcGF0aCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdG8gY2hlY2suXG4gKiBAcGFyYW0gY29udGV4dC5wYXRoIC0gVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0gY29udGV4dC5icmFuY2ggLSBUaGUgYnJhbmNoIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgbGFzdCBmaWVsZCBvZiBhIHBhdGggaXMgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gaGFzT3B0aW9uYWwoeyBwYXRoLCBicmFuY2ggfSkge1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAoMCwgbWlzY18xLmhhc1Byb3BlcnR5KShicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDJdLCBmaWVsZCk7XG59XG4vKipcbiAqIEEgc3RydWN0IHdoaWNoIGFsbG93cyB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRvIGJlIGFic2VudCwgb3IgdG8gYmUgcHJlc2VudFxuICogYXMgbG9uZyBhcyBpdCdzIHZhbGlkIGFuZCBub3Qgc2V0IHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIFRoaXMgc3RydWN0IHNob3VsZCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHtAbGluayBvYmplY3R9IGZyb20gdGhpc1xuICogbGlicmFyeSwgdG8gZ2V0IHByb3BlciB0eXBlIGluZmVyZW5jZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGV4YWN0T3B0aW9uYWxgIGFuZCBgb2JqZWN0YCBmcm9tIGBAbWV0YW1hc2svc3VwZXJzdHJ1Y3RAPj0zLjIuMGAgaW5zdGVhZC5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGNoZWNrIHRoZSB2YWx1ZSBhZ2FpbnN0LCBpZiBwcmVzZW50LlxuICogQHJldHVybnMgQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkLCBvciBub3QgcHJlc2VudC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RydWN0ID0gb2JqZWN0KHtcbiAqICAgZm9vOiBleGFjdE9wdGlvbmFsKHN0cmluZygpKSxcbiAqICAgYmFyOiBleGFjdE9wdGlvbmFsKG51bWJlcigpKSxcbiAqICAgYmF6OiBvcHRpb25hbChib29sZWFuKCkpLFxuICogICBxdXg6IHVua25vd24oKSxcbiAqIH0pO1xuICpcbiAqIHR5cGUgVHlwZSA9IEluZmVyPHR5cGVvZiBzdHJ1Y3Q+O1xuICogLy8gVHlwZSBpcyBlcXVpdmFsZW50IHRvOlxuICogLy8ge1xuICogLy8gICBmb28/OiBzdHJpbmc7XG4gKiAvLyAgIGJhcj86IG51bWJlcjtcbiAqIC8vICAgYmF6PzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAqIC8vICAgcXV4OiB1bmtub3duO1xuICogLy8gfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBzdXBlcnN0cnVjdF8xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdHlwZTogYG9wdGlvbmFsICR7c3RydWN0LnR5cGV9YCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpLFxuICAgIH0pO1xufVxuZXhwb3J0cy5leGFjdE9wdGlvbmFsID0gZXhhY3RPcHRpb25hbDtcbi8qKlxuICogVmFsaWRhdGUgYW4gdW5rbm93biBpbnB1dCB0byBiZSB2YWxpZCBKU09OLlxuICpcbiAqIFVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIEpTT04gc3RydWN0cy5cbiAqXG4gKiBAcGFyYW0ganNvbiAtIEFuIHVua25vd24gdmFsdWUuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZCBKU09OLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbihqc29uKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwgfHwgdHlwZW9mIGpzb24gPT09ICdib29sZWFuJyB8fCB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKGpzb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxldCBldmVyeSA9IHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmluZyBsaW50aW5nIGVycm9yIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgICAgICAvLyBhbmQgcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50IGluIHRoaXMgc3BlY2lmaWMgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVKc29uKGpzb25baV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoanNvbik7XG4gICAgICAgIC8vIElnbm9yaW5nIGxpbnRpbmcgZXJyb3JzIHNpbmNlIGZvci1vZiBpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGEgbm9ybWFsIGZvci1sb29wXG4gICAgICAgIC8vIGFuZCBwZXJmb3JtYW5jZSBpcyBpbXBvcnRhbnQgaW4gdGhpcyBzcGVjaWZpYyBmdW5jdGlvbi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cmllc1tpXVswXSAhPT0gJ3N0cmluZycgfHwgIXZhbGlkYXRlSnNvbihlbnRyaWVzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgIGV2ZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHN0cnVjdCBpcyB1bnNhZmUuIEZvciBzYWZlIHZhbGlkYXRpb24sIHVzZSB7QGxpbmsgSnNvblN0cnVjdH0uXG4gKi9cbmV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ0pTT04nLCAoanNvbikgPT4gdmFsaWRhdGVKc29uKGpzb24pKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2FuaXRpemVzIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgc28gdGhhdCBpdCBpcyBzYWZlIHRvXG4gKiB1c2Ugd2l0aCB1bnRydXN0ZWQgaW5wdXQuXG4gKi9cbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLmFueSkoKSwgJ0pTT04nLCAodmFsdWUpID0+ICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksICh2YWx1ZSkgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKHByb3BLZXksIHByb3BWYWx1ZSkgPT4ge1xuICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgaWYgKHByb3BLZXkgPT09ICdfX3Byb3RvX18nIHx8IHByb3BLZXkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbn0pKSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRTYWZlSnNvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gc2FuaXRpemVkIEpTT04uXG4gKlxuICogTm90ZTpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBzYW5pdGl6ZWQgSnNvblN0cnVjdCBmb3IgdmFsaWRhdGlvblxuICogdGhhdCBhcHBsaWVzIHN0cmluZ2lmeSBhbmQgdGhlbiBwYXJzZSBvZiBhIHZhbHVlIHByb3ZpZGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gZ2V0dGVycyB3aGljaCBjYW4gaGF2ZSBzaWRlIGVmZmVjdHNcbiAqIHRoYXQgY2FuIGNhdXNlIHNlY3VyaXR5IGlzc3Vlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBKU09OIHN0cnVjdHVyZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyBTYW5pdGl6ZWQgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmdldFNhZmVKc29uID0gZ2V0U2FmZUpzb247XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uU2l6ZSh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0SnNvblNpemUgPSBnZXRKc29uU2l6ZTtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogZXhhY3RPcHRpb25hbChleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiBleGFjdE9wdGlvbmFsKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgZXhwb3J0cy5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0ge1xuICAgICAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICAgICAgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgcGVybWl0TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/json.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/keyring.cjs":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/keyring.cjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=keyring.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5janM/ODU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXJpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/keyring.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/logging.cjs":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/logging.cjs ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/../../node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)('metamask');\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nfunction createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nfunction createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger;\n//# sourceMappingURL=logging.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMkJBQTJCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhHQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmNqcz85Y2I4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/logging.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.getKnownPropertyNames = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\nexports.getKnownPropertyNames = getKnownPropertyNames;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(exports.ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize;\n//# sourceMappingURL=misc.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLGVBQWUsR0FBRyxxQkFBcUIsR0FBRyxnQ0FBZ0MsR0FBRyxnQkFBZ0IsR0FBRyw2QkFBNkIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUI7QUFDeFI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuY2pzP2FhZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmdldEtub3duUHJvcGVydHlOYW1lcyA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZnVuY3Rpb24gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xufVxuZXhwb3J0cy5nZXRLbm93blByb3BlcnR5TmFtZXMgPSBnZXRLbm93blByb3BlcnR5TmFtZXM7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICh2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/number.cjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/number.cjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.cjs\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */\nconst numberToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */\nconst bigIntToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */\nconst hexToNumber = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */\nconst hexToBigInt = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt;\n//# sourceMappingURL=number.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3JGLGlCQUFpQixtQkFBTyxDQUFDLHdIQUFjO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxrSEFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9udW1iZXIuY2pzPzIyZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/number.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/opaque.cjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/opaque.cjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=opaque.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuY2pzPzUwNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/opaque.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/promise.cjs":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/promise.cjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDeferredPromise = void 0;\n/**\n * Create a defered Promise.\n *\n * If the Promise is rejected prior to a handler being added, this can result in an\n * `UnhandledPromiseRejection` error. Optionally this can be suppressed with the\n * `suppressUnhandledRejection` flag, as it's common to belatedly handle deferred Promises, or to\n * ignore them if they're no longer relevant (e.g. related to a cancelled request).\n *\n * However, be very careful that you have handled the Promise if you do this. Suppressing these\n * errors is dangerous, they exist for good reason. An unhandled rejection can hide errors, making\n * debugging extremely difficult. They should only be suppressed if you're confident that the\n * Promise is always handled correctly, in both the success and failure cases.\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n * @template Result - The result type of the Promise.\n */\nfunction createDeferredPromise({ suppressUnhandledRejection = false, } = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((innerResolve, innerReject) => {\n        resolve = innerResolve;\n        reject = innerReject;\n    });\n    if (suppressUnhandledRejection) {\n        promise.catch((_error) => {\n            // This handler is used to suppress the UnhandledPromiseRejection error\n        });\n    }\n    // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n    return { promise, resolve, reject };\n}\nexports.createDeferredPromise = createDeferredPromise;\n//# sourceMappingURL=promise.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3Byb21pc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNDQUFzQyxJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9wcm9taXNlLmNqcz9jNDNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGRlZmVyZWQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCBwcmlvciB0byBhIGhhbmRsZXIgYmVpbmcgYWRkZWQsIHRoaXMgY2FuIHJlc3VsdCBpbiBhblxuICogYFVuaGFuZGxlZFByb21pc2VSZWplY3Rpb25gIGVycm9yLiBPcHRpb25hbGx5IHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgd2l0aCB0aGVcbiAqIGBzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbmAgZmxhZywgYXMgaXQncyBjb21tb24gdG8gYmVsYXRlZGx5IGhhbmRsZSBkZWZlcnJlZCBQcm9taXNlcywgb3IgdG9cbiAqIGlnbm9yZSB0aGVtIGlmIHRoZXkncmUgbm8gbG9uZ2VyIHJlbGV2YW50IChlLmcuIHJlbGF0ZWQgdG8gYSBjYW5jZWxsZWQgcmVxdWVzdCkuXG4gKlxuICogSG93ZXZlciwgYmUgdmVyeSBjYXJlZnVsIHRoYXQgeW91IGhhdmUgaGFuZGxlZCB0aGUgUHJvbWlzZSBpZiB5b3UgZG8gdGhpcy4gU3VwcHJlc3NpbmcgdGhlc2VcbiAqIGVycm9ycyBpcyBkYW5nZXJvdXMsIHRoZXkgZXhpc3QgZm9yIGdvb2QgcmVhc29uLiBBbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGNhbiBoaWRlIGVycm9ycywgbWFraW5nXG4gKiBkZWJ1Z2dpbmcgZXh0cmVtZWx5IGRpZmZpY3VsdC4gVGhleSBzaG91bGQgb25seSBiZSBzdXBwcmVzc2VkIGlmIHlvdSdyZSBjb25maWRlbnQgdGhhdCB0aGVcbiAqIFByb21pc2UgaXMgYWx3YXlzIGhhbmRsZWQgY29ycmVjdGx5LCBpbiBib3RoIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBhcmdzLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uIC0gVGhpcyBvcHRpb24gYWRkcyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyXG4gKiB0byB0aGUgUHJvbWlzZSB0byBzdXBwcmVzcyB0aGUgVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbiBlcnJvci4gVGhpcyBjYW4gYmVcbiAqIHVzZWZ1bCBpZiB0aGUgZGVmZXJyZWQgUHJvbWlzZSBpcyBzb21ldGltZXMgaW50ZW50aW9uYWxseSBub3QgdXNlZC5cbiAqIEByZXR1cm5zIEEgZGVmZXJyZWQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIFByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSh7IHN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBpbm5lclJlc29sdmU7XG4gICAgICAgIHJlamVjdCA9IGlubmVyUmVqZWN0O1xuICAgIH0pO1xuICAgIGlmIChzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbikge1xuICAgICAgICBwcm9taXNlLmNhdGNoKChfZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHN1cHByZXNzIHRoZSBVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGtub3cgdGhhdCB0aGVzZSBhcmUgYXNzaWduZWQsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3RcbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/promise.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/superstruct.cjs":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/superstruct.cjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.definePattern = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * @example\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * type EthAddress = Infer<typeof EthAddressStruct>; // string\n *\n * const CaipChainIdStruct = defineTypedPattern<`${string}:${string}`>(\n *   'CaipChainId',\n *   /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/u;\n * );\n * type CaipChainId = Infer<typeof CaipChainIdStruct>; // `${string}:${string}`\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @template Pattern - The pattern type, defaults to `string`.\n * @returns A new string-struct that matches the given pattern.\n */\nfunction definePattern(name, pattern) {\n    return (0, superstruct_1.define)(name, (value) => {\n        return typeof value === 'string' && pattern.test(value);\n    });\n}\nexports.definePattern = definePattern;\n//# sourceMappingURL=superstruct.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3N1cGVyc3RydWN0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsc0JBQXNCLG1CQUFPLENBQUMsMklBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUc7QUFDeEUscURBQXFEO0FBQ3JEO0FBQ0EsbURBQW1ELE9BQU8sR0FBRyxPQUFPO0FBQ3BFO0FBQ0EsaUJBQWlCLElBQUksZUFBZSxLQUFLO0FBQ3pDO0FBQ0EsdURBQXVELE1BQU0sT0FBTyxHQUFHLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3N1cGVyc3RydWN0LmNqcz8xNjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQYXR0ZXJuID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG4vKipcbiAqIERlZmluZXMgYSBuZXcgc3RyaW5nLXN0cnVjdCBtYXRjaGluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgRXRoQWRkcmVzc1N0cnVjdCA9IGRlZmluZVBhdHRlcm4oJ0V0aEFkZHJlc3MnLCAvXjB4WzAtOWEtZl17NDB9JC9pdSk7XG4gKiB0eXBlIEV0aEFkZHJlc3MgPSBJbmZlcjx0eXBlb2YgRXRoQWRkcmVzc1N0cnVjdD47IC8vIHN0cmluZ1xuICpcbiAqIGNvbnN0IENhaXBDaGFpbklkU3RydWN0ID0gZGVmaW5lVHlwZWRQYXR0ZXJuPGAke3N0cmluZ306JHtzdHJpbmd9YD4oXG4gKiAgICdDYWlwQ2hhaW5JZCcsXG4gKiAgIC9eWy1hLXowLTldezMsOH06Wy1fYS16QS1aMC05XXsxLDMyfSQvdTtcbiAqICk7XG4gKiB0eXBlIENhaXBDaGFpbklkID0gSW5mZXI8dHlwZW9mIENhaXBDaGFpbklkU3RydWN0PjsgLy8gYCR7c3RyaW5nfToke3N0cmluZ31gXG4gKiBAcGFyYW0gbmFtZSAtIFR5cGUgbmFtZS5cbiAqIEBwYXJhbSBwYXR0ZXJuIC0gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoLlxuICogQHRlbXBsYXRlIFBhdHRlcm4gLSBUaGUgcGF0dGVybiB0eXBlLCBkZWZhdWx0cyB0byBgc3RyaW5nYC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cmluZy1zdHJ1Y3QgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5mdW5jdGlvbiBkZWZpbmVQYXR0ZXJuKG5hbWUsIHBhdHRlcm4pIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKShuYW1lLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgcGF0dGVybi50ZXN0KHZhbHVlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmaW5lUGF0dGVybiA9IGRlZmluZVBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBlcnN0cnVjdC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/superstruct.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/time.cjs":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/time.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */\nvar Duration;\n(function (Duration) {\n    /**\n     * A millisecond.\n     */\n    Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */\n    Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */\n    Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */\n    Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */\n    Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */\n    Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */\n    Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name) => {\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nfunction inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, 'count');\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nfunction timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, 'timestamp');\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince;\n//# sourceMappingURL=time.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSywrQ0FBK0MsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuY2pzP2U5NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/time.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/transaction-types.cjs":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/transaction-types.cjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=transaction-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmNqcz85MzY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/transaction-types.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/unitsConversion.cjs":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/unitsConversion.cjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable operator-assignment */\n/*\nPrimary Attribution\nRichard Moore <ricmoo@me.com>\nhttps://github.com/ethers-io\n\nNote, Richard is a god of ether gods. Follow and respect him, and use Ethers.io!\n*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toWei = exports.fromWei = exports.numberToString = exports.getValueOfUnit = exports.unitMap = exports.numericToBigInt = void 0;\nconst zero = BigInt(0);\nconst negative1 = BigInt(-1);\n/**\n * Converts a string, number, or bigint to a bigint.\n *\n * @param arg - The value to convert to bigint.\n * @returns The bigint representation of the input.\n * @throws Error if the input type cannot be converted to bigint.\n */\nfunction numericToBigInt(arg) {\n    if (typeof arg === 'string') {\n        return BigInt(arg);\n    }\n    if (typeof arg === 'number') {\n        return BigInt(arg);\n    }\n    if (typeof arg === 'bigint') {\n        return arg;\n    }\n    throw new Error(`Cannot convert ${typeof arg} to BigInt`);\n}\nexports.numericToBigInt = numericToBigInt;\n// complete ethereum unit map\nexports.unitMap = {\n    noether: '0',\n    wei: '1',\n    kwei: '1000',\n    Kwei: '1000',\n    babbage: '1000',\n    femtoether: '1000',\n    mwei: '1000000',\n    Mwei: '1000000',\n    lovelace: '1000000',\n    picoether: '1000000',\n    gwei: '1000000000',\n    Gwei: '1000000000',\n    shannon: '1000000000',\n    nanoether: '1000000000',\n    nano: '1000000000',\n    szabo: '1000000000000',\n    microether: '1000000000000',\n    micro: '1000000000000',\n    finney: '1000000000000000',\n    milliether: '1000000000000000',\n    milli: '1000000000000000',\n    ether: '1000000000000000000',\n    kether: '1000000000000000000000',\n    grand: '1000000000000000000000',\n    mether: '1000000000000000000000000',\n    gether: '1000000000000000000000000000',\n    tether: '1000000000000000000000000000000',\n};\n// Pre-computed unit values as BigInt for performance\nconst unitMapBigInt = Object.fromEntries(Object.entries(exports.unitMap).map(([key, value]) => [key, BigInt(value)]));\nconst unitLengths = Object.fromEntries(Object.entries(exports.unitMap).map(([key, value]) => [key, value.length - 1 || 1]));\nconst NUMBER_REGEX = /^-?[0-9.]+$/u;\nconst FRACTION_REGEX = /^([0-9]*[1-9]|0)(0*)/u;\nconst COMMIFY_REGEX = /\\B(?=(\\d{3})+(?!\\d))/gu;\n/**\n * Returns value of unit in Wei.\n *\n * @param unitInput - The unit to convert to, default ether.\n * @returns Value of the unit (in Wei).\n * @throws Error if the unit is not correct.\n */\nfunction getValueOfUnit(unitInput = 'ether') {\n    const unit = unitInput.toLowerCase();\n    const unitValue = unitMapBigInt[unit];\n    if (unitValue === undefined) {\n        throw new Error(`The unit provided ${unitInput} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    return unitValue;\n}\nexports.getValueOfUnit = getValueOfUnit;\n/**\n * Converts a number to a string.\n *\n * @param arg - The number to convert to a string.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nfunction numberToString(arg) {\n    if (typeof arg === 'string') {\n        if (!NUMBER_REGEX.test(arg)) {\n            throw new Error(`while converting number to string, invalid number value '${arg}', should be a number matching (^-?[0-9.]+).`);\n        }\n        return arg;\n    }\n    if (typeof arg === 'number') {\n        return String(arg);\n    }\n    if (typeof arg === 'bigint') {\n        return arg.toString();\n    }\n    throw new Error(`while converting number to string, invalid number value '${String(arg)}' type ${typeof arg}.`);\n}\nexports.numberToString = numberToString;\n/**\n * Converts a number from Wei to a string.\n *\n * @param weiInput - The number to convert from Wei.\n * @param unit - The unit to convert to, default ether.\n * @param optionsInput - The options to use for the conversion.\n * @param optionsInput.pad - Whether to pad the fractional part with zeros.\n * @param optionsInput.commify - Whether to add commas to separate thousands.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nfunction fromWei(weiInput, unit, optionsInput) {\n    let wei = numericToBigInt(weiInput);\n    const negative = wei < zero;\n    const unitLower = unit.toLowerCase();\n    const base = unitMapBigInt[unitLower];\n    const baseLength = unitLengths[unitLower];\n    const options = optionsInput ?? {};\n    if (base === undefined) {\n        throw new Error(`The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    // Handle special case of noether (base = 0)\n    if (base === zero) {\n        return negative ? '-0' : '0';\n    }\n    if (negative) {\n        wei = wei * negative1;\n    }\n    let fraction = (wei % base).toString();\n    fraction = fraction.padStart(baseLength, '0');\n    if (!options.pad) {\n        const fractionMatch = fraction.match(FRACTION_REGEX);\n        // istanbul ignore next: defensive fallback that's never reachable but necessary to satisfy TS\n        fraction = fractionMatch?.[1] ?? '0';\n    }\n    let whole = (wei / base).toString();\n    if (options.commify) {\n        whole = whole.replace(COMMIFY_REGEX, ',');\n    }\n    let value = `${whole}${fraction === '0' ? '' : `.${fraction}`}`;\n    if (negative) {\n        value = `-${value}`;\n    }\n    return value;\n}\nexports.fromWei = fromWei;\n/**\n * Converts a number to Wei.\n *\n * @param etherInput - The number to convert to Wei.\n * @param unit - The unit to convert to, default ether.\n * @returns The number in Wei.\n * @throws Error if the number is invalid.\n */\nfunction toWei(etherInput, unit) {\n    const unitLower = unit.toLowerCase();\n    const base = unitMapBigInt[unitLower];\n    const baseLength = unitLengths[unitLower];\n    if (base === undefined) {\n        throw new Error(`The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(exports.unitMap, null, 2)}`);\n    }\n    // Handle special case of noether (base = 0)\n    if (base === zero) {\n        return zero;\n    }\n    // Fast path for bigint inputs when unit is wei (no conversion needed)\n    if (typeof etherInput === 'bigint' && unitLower === 'wei') {\n        return etherInput;\n    }\n    // Fast path for bigint inputs with whole units (no fractional part)\n    if (typeof etherInput === 'bigint') {\n        return etherInput * base;\n    }\n    let ether = numberToString(etherInput);\n    // Is it negative?\n    const negative = ether.startsWith('-');\n    if (negative) {\n        ether = ether.substring(1);\n    }\n    if (ether === '.') {\n        throw new Error(`While converting number ${etherInput} to wei, invalid value`);\n    }\n    // Split it into a whole and fractional part\n    const comps = ether.split('.');\n    if (comps.length > 2) {\n        throw new Error(`While converting number ${etherInput} to wei,  too many decimal points`);\n    }\n    let whole = comps[0];\n    let fraction = comps[1];\n    if (!whole) {\n        whole = '0';\n    }\n    if (!fraction) {\n        fraction = '0';\n    }\n    if (fraction.length > baseLength) {\n        throw new Error(`While converting number ${etherInput} to wei, too many decimal places`);\n    }\n    fraction = fraction.padEnd(baseLength, '0');\n    const wholeBigInt = BigInt(whole);\n    const fractionBigInt = BigInt(fraction);\n    let wei = wholeBigInt * base + fractionBigInt;\n    if (negative) {\n        wei = wei * negative1;\n    }\n    return wei;\n}\nexports.toWei = toWei;\n//# sourceMappingURL=unitsConversion.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3VuaXRzQ29udmVyc2lvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxlQUFlLEdBQUcsdUJBQXVCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLDJEQUEyRCx5Q0FBeUM7QUFDNUo7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFlBQVksU0FBUyxXQUFXO0FBQ2hIO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sMkRBQTJELHlDQUF5QztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLEVBQUUsNEJBQTRCLFNBQVMsRUFBRTtBQUNsRTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLDJEQUEyRCx5Q0FBeUM7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3VuaXRzQ29udmVyc2lvbi5janM/YWQzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIG9wZXJhdG9yLWFzc2lnbm1lbnQgKi9cbi8qXG5QcmltYXJ5IEF0dHJpYnV0aW9uXG5SaWNoYXJkIE1vb3JlIDxyaWNtb29AbWUuY29tPlxuaHR0cHM6Ly9naXRodWIuY29tL2V0aGVycy1pb1xuXG5Ob3RlLCBSaWNoYXJkIGlzIGEgZ29kIG9mIGV0aGVyIGdvZHMuIEZvbGxvdyBhbmQgcmVzcGVjdCBoaW0sIGFuZCB1c2UgRXRoZXJzLmlvIVxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9XZWkgPSBleHBvcnRzLmZyb21XZWkgPSBleHBvcnRzLm51bWJlclRvU3RyaW5nID0gZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGV4cG9ydHMudW5pdE1hcCA9IGV4cG9ydHMubnVtZXJpY1RvQmlnSW50ID0gdm9pZCAwO1xuY29uc3QgemVybyA9IEJpZ0ludCgwKTtcbmNvbnN0IG5lZ2F0aXZlMSA9IEJpZ0ludCgtMSk7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJpZ2ludCB0byBhIGJpZ2ludC5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYmlnaW50LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBpbnB1dCB0eXBlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYmlnaW50LlxuICovXG5mdW5jdGlvbiBudW1lcmljVG9CaWdJbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgJHt0eXBlb2YgYXJnfSB0byBCaWdJbnRgKTtcbn1cbmV4cG9ydHMubnVtZXJpY1RvQmlnSW50ID0gbnVtZXJpY1RvQmlnSW50O1xuLy8gY29tcGxldGUgZXRoZXJldW0gdW5pdCBtYXBcbmV4cG9ydHMudW5pdE1hcCA9IHtcbiAgICBub2V0aGVyOiAnMCcsXG4gICAgd2VpOiAnMScsXG4gICAga3dlaTogJzEwMDAnLFxuICAgIEt3ZWk6ICcxMDAwJyxcbiAgICBiYWJiYWdlOiAnMTAwMCcsXG4gICAgZmVtdG9ldGhlcjogJzEwMDAnLFxuICAgIG13ZWk6ICcxMDAwMDAwJyxcbiAgICBNd2VpOiAnMTAwMDAwMCcsXG4gICAgbG92ZWxhY2U6ICcxMDAwMDAwJyxcbiAgICBwaWNvZXRoZXI6ICcxMDAwMDAwJyxcbiAgICBnd2VpOiAnMTAwMDAwMDAwMCcsXG4gICAgR3dlaTogJzEwMDAwMDAwMDAnLFxuICAgIHNoYW5ub246ICcxMDAwMDAwMDAwJyxcbiAgICBuYW5vZXRoZXI6ICcxMDAwMDAwMDAwJyxcbiAgICBuYW5vOiAnMTAwMDAwMDAwMCcsXG4gICAgc3phYm86ICcxMDAwMDAwMDAwMDAwJyxcbiAgICBtaWNyb2V0aGVyOiAnMTAwMDAwMDAwMDAwMCcsXG4gICAgbWljcm86ICcxMDAwMDAwMDAwMDAwJyxcbiAgICBmaW5uZXk6ICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBtaWxsaWV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgbWlsbGk6ICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBldGhlcjogJzEwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgIGtldGhlcjogJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgIGdyYW5kOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgbWV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgZ2V0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgdGV0aGVyOiAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG59O1xuLy8gUHJlLWNvbXB1dGVkIHVuaXQgdmFsdWVzIGFzIEJpZ0ludCBmb3IgcGVyZm9ybWFuY2VcbmNvbnN0IHVuaXRNYXBCaWdJbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXhwb3J0cy51bml0TWFwKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgQmlnSW50KHZhbHVlKV0pKTtcbmNvbnN0IHVuaXRMZW5ndGhzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGV4cG9ydHMudW5pdE1hcCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHZhbHVlLmxlbmd0aCAtIDEgfHwgMV0pKTtcbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC9eLT9bMC05Ll0rJC91O1xuY29uc3QgRlJBQ1RJT05fUkVHRVggPSAvXihbMC05XSpbMS05XXwwKSgwKikvdTtcbmNvbnN0IENPTU1JRllfUkVHRVggPSAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZ3U7XG4vKipcbiAqIFJldHVybnMgdmFsdWUgb2YgdW5pdCBpbiBXZWkuXG4gKlxuICogQHBhcmFtIHVuaXRJbnB1dCAtIFRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXIuXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgdW5pdCAoaW4gV2VpKS5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIHVuaXQgaXMgbm90IGNvcnJlY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlT2ZVbml0KHVuaXRJbnB1dCA9ICdldGhlcicpIHtcbiAgICBjb25zdCB1bml0ID0gdW5pdElucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdW5pdFZhbHVlID0gdW5pdE1hcEJpZ0ludFt1bml0XTtcbiAgICBpZiAodW5pdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXRJbnB1dH0gZG9lc24ndCBleGlzdCwgcGxlYXNlIHVzZSB0aGUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdW5pdHMgJHtKU09OLnN0cmluZ2lmeShleHBvcnRzLnVuaXRNYXAsIG51bGwsIDIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdFZhbHVlO1xufVxuZXhwb3J0cy5nZXRWYWx1ZU9mVW5pdCA9IGdldFZhbHVlT2ZVbml0O1xuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvU3RyaW5nKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIU5VTUJFUl9SRUdFWC50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2hpbGUgY29udmVydGluZyBudW1iZXIgdG8gc3RyaW5nLCBpbnZhbGlkIG51bWJlciB2YWx1ZSAnJHthcmd9Jywgc2hvdWxkIGJlIGEgbnVtYmVyIG1hdGNoaW5nICheLT9bMC05Ll0rKS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyIHRvIHN0cmluZywgaW52YWxpZCBudW1iZXIgdmFsdWUgJyR7U3RyaW5nKGFyZyl9JyB0eXBlICR7dHlwZW9mIGFyZ30uYCk7XG59XG5leHBvcnRzLm51bWJlclRvU3RyaW5nID0gbnVtYmVyVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIGZyb20gV2VpIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB3ZWlJbnB1dCAtIFRoZSBudW1iZXIgdG8gY29udmVydCBmcm9tIFdlaS5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlci5cbiAqIEBwYXJhbSBvcHRpb25zSW5wdXQgLSBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBjb252ZXJzaW9uLlxuICogQHBhcmFtIG9wdGlvbnNJbnB1dC5wYWQgLSBXaGV0aGVyIHRvIHBhZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggemVyb3MuXG4gKiBAcGFyYW0gb3B0aW9uc0lucHV0LmNvbW1pZnkgLSBXaGV0aGVyIHRvIGFkZCBjb21tYXMgdG8gc2VwYXJhdGUgdGhvdXNhbmRzLlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGZyb21XZWkod2VpSW5wdXQsIHVuaXQsIG9wdGlvbnNJbnB1dCkge1xuICAgIGxldCB3ZWkgPSBudW1lcmljVG9CaWdJbnQod2VpSW5wdXQpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gd2VpIDwgemVybztcbiAgICBjb25zdCB1bml0TG93ZXIgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYmFzZSA9IHVuaXRNYXBCaWdJbnRbdW5pdExvd2VyXTtcbiAgICBjb25zdCBiYXNlTGVuZ3RoID0gdW5pdExlbmd0aHNbdW5pdExvd2VyXTtcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0lucHV0ID8/IHt9O1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXR9IGRvZXNuJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzICR7SlNPTi5zdHJpbmdpZnkoZXhwb3J0cy51bml0TWFwLCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBub2V0aGVyIChiYXNlID0gMClcbiAgICBpZiAoYmFzZSA9PT0gemVybykge1xuICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAnLTAnIDogJzAnO1xuICAgIH1cbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgd2VpID0gd2VpICogbmVnYXRpdmUxO1xuICAgIH1cbiAgICBsZXQgZnJhY3Rpb24gPSAod2VpICUgYmFzZSkudG9TdHJpbmcoKTtcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZFN0YXJ0KGJhc2VMZW5ndGgsICcwJyk7XG4gICAgaWYgKCFvcHRpb25zLnBhZCkge1xuICAgICAgICBjb25zdCBmcmFjdGlvbk1hdGNoID0gZnJhY3Rpb24ubWF0Y2goRlJBQ1RJT05fUkVHRVgpO1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGVmZW5zaXZlIGZhbGxiYWNrIHRoYXQncyBuZXZlciByZWFjaGFibGUgYnV0IG5lY2Vzc2FyeSB0byBzYXRpc2Z5IFRTXG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb25NYXRjaD8uWzFdID8/ICcwJztcbiAgICB9XG4gICAgbGV0IHdob2xlID0gKHdlaSAvIGJhc2UpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG9wdGlvbnMuY29tbWlmeSkge1xuICAgICAgICB3aG9sZSA9IHdob2xlLnJlcGxhY2UoQ09NTUlGWV9SRUdFWCwgJywnKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gYCR7d2hvbGV9JHtmcmFjdGlvbiA9PT0gJzAnID8gJycgOiBgLiR7ZnJhY3Rpb259YH1gO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IGAtJHt2YWx1ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmZyb21XZWkgPSBmcm9tV2VpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBXZWkuXG4gKlxuICogQHBhcmFtIGV0aGVySW5wdXQgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gV2VpLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBpbiBXZWkuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdG9XZWkoZXRoZXJJbnB1dCwgdW5pdCkge1xuICAgIGNvbnN0IHVuaXRMb3dlciA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBiYXNlID0gdW5pdE1hcEJpZ0ludFt1bml0TG93ZXJdO1xuICAgIGNvbnN0IGJhc2VMZW5ndGggPSB1bml0TGVuZ3Roc1t1bml0TG93ZXJdO1xuICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCBwcm92aWRlZCAke3VuaXR9IGRvZXNuJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzICR7SlNPTi5zdHJpbmdpZnkoZXhwb3J0cy51bml0TWFwLCBudWxsLCAyKX1gKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBub2V0aGVyIChiYXNlID0gMClcbiAgICBpZiAoYmFzZSA9PT0gemVybykge1xuICAgICAgICByZXR1cm4gemVybztcbiAgICB9XG4gICAgLy8gRmFzdCBwYXRoIGZvciBiaWdpbnQgaW5wdXRzIHdoZW4gdW5pdCBpcyB3ZWkgKG5vIGNvbnZlcnNpb24gbmVlZGVkKVxuICAgIGlmICh0eXBlb2YgZXRoZXJJbnB1dCA9PT0gJ2JpZ2ludCcgJiYgdW5pdExvd2VyID09PSAnd2VpJykge1xuICAgICAgICByZXR1cm4gZXRoZXJJbnB1dDtcbiAgICB9XG4gICAgLy8gRmFzdCBwYXRoIGZvciBiaWdpbnQgaW5wdXRzIHdpdGggd2hvbGUgdW5pdHMgKG5vIGZyYWN0aW9uYWwgcGFydClcbiAgICBpZiAodHlwZW9mIGV0aGVySW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBldGhlcklucHV0ICogYmFzZTtcbiAgICB9XG4gICAgbGV0IGV0aGVyID0gbnVtYmVyVG9TdHJpbmcoZXRoZXJJbnB1dCk7XG4gICAgLy8gSXMgaXQgbmVnYXRpdmU/XG4gICAgY29uc3QgbmVnYXRpdmUgPSBldGhlci5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIGV0aGVyID0gZXRoZXIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoZXRoZXIgPT09ICcuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyICR7ZXRoZXJJbnB1dH0gdG8gd2VpLCBpbnZhbGlkIHZhbHVlYCk7XG4gICAgfVxuICAgIC8vIFNwbGl0IGl0IGludG8gYSB3aG9sZSBhbmQgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgY29tcHMgPSBldGhlci5zcGxpdCgnLicpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2hpbGUgY29udmVydGluZyBudW1iZXIgJHtldGhlcklucHV0fSB0byB3ZWksICB0b28gbWFueSBkZWNpbWFsIHBvaW50c2ApO1xuICAgIH1cbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXTtcbiAgICBsZXQgZnJhY3Rpb24gPSBjb21wc1sxXTtcbiAgICBpZiAoIXdob2xlKSB7XG4gICAgICAgIHdob2xlID0gJzAnO1xuICAgIH1cbiAgICBpZiAoIWZyYWN0aW9uKSB7XG4gICAgICAgIGZyYWN0aW9uID0gJzAnO1xuICAgIH1cbiAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gYmFzZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoaWxlIGNvbnZlcnRpbmcgbnVtYmVyICR7ZXRoZXJJbnB1dH0gdG8gd2VpLCB0b28gbWFueSBkZWNpbWFsIHBsYWNlc2ApO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZEVuZChiYXNlTGVuZ3RoLCAnMCcpO1xuICAgIGNvbnN0IHdob2xlQmlnSW50ID0gQmlnSW50KHdob2xlKTtcbiAgICBjb25zdCBmcmFjdGlvbkJpZ0ludCA9IEJpZ0ludChmcmFjdGlvbik7XG4gICAgbGV0IHdlaSA9IHdob2xlQmlnSW50ICogYmFzZSArIGZyYWN0aW9uQmlnSW50O1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB3ZWkgPSB3ZWkgKiBuZWdhdGl2ZTE7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnRzLnRvV2VpID0gdG9XZWk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0c0NvbnZlcnNpb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/unitsConversion.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/versions.cjs":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/versions.cjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/index.cjs\");\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * A struct for validating a version string.\n */\nexports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nfunction isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nfunction isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nfunction assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nfunction assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nfunction gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nfunction gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nfunction satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true,\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange;\n//# sourceMappingURL=versions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ2xQLHNCQUFzQixtQkFBTyxDQUFDLDJJQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyx3SEFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQjtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5janM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/versions.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.mjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssertionError: () => (/* binding */ AssertionError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertExhaustive: () => (/* binding */ assertExhaustive),\n/* harmony export */   assertStruct: () => (/* binding */ assertStruct)\n/* harmony export */ });\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/struct.mjs\");\n/* harmony import */ var _errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.mjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.mjs\");\n\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0,_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\n//# sourceMappingURL=assert.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9FO0FBQ3JCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRSxJQUFJLGFBQWE7QUFDakI7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQWlCO0FBQ3pCO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxJQUFJLDRDQUE0QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BteS1zY29wZS9hcm4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5tanM/NzI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQgYXMgYXNzZXJ0U3VwZXJzdHJ1Y3QgfSBmcm9tIFwiQG1ldGFtYXNrL3N1cGVyc3RydWN0XCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9lcnJvcnMubWpzXCI7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBjb25zdHJ1Y3RvciwgaS5lLiwgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aFxuICogdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgZm4/LnByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdzdHJpbmcnKTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gb2J0YWluIHRoZSBtZXNzYWdlIGZyb20gYSBwb3NzaWJsZSBlcnJvciBvYmplY3QuIElmIGl0IGlzXG4gKiBwb3NzaWJsZSB0byBkbyBzbywgYW55IHRyYWlsaW5nIHBlcmlvZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbWVzc2FnZTtcbiAqIG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIHdpdGhvdXQgYW55IHRyYWlsaW5nIHBlcmlvZCBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdFxuICogd2l0aCBhIGBtZXNzYWdlYCBwcm9wZXJ0eTsgdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgd2l0aG91dCBhbnkgdHJhaWxpbmdcbiAqIHBlcmlvZCBpZiBpdCBpcyBub3QgYHVuZGVmaW5lZGAgb3IgYG51bGxgOyBvdGhlcndpc2UgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2VXaXRob3V0VHJhaWxpbmdQZXJpb2QoZXJyb3IpIHtcbiAgICAvLyBXZSdsbCBhZGQgb3VyIG93biBwZXJpb2QuXG4gICAgcmV0dXJuIGdldEVycm9yTWVzc2FnZShlcnJvcikucmVwbGFjZSgvXFwuJC91LCAnJyk7XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYW4ge0BsaW5rIEFzc2VydGlvbkVycm9yQ29uc3RydWN0b3J9IGVycm9yLlxuICpcbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0NvbnN0cnVjdGFibGUoRXJyb3JXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yV3JhcHBlcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yV3JhcHBlcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVycm9yIGNsYXNzIHRoYXQgaXMgdGhyb3duIGlmIGFuIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWx1ZSBhZ2FpbnN0IGEgU3VwZXJzdHJ1Y3Qgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBBIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gKiBcIkFzc2VydGlvbiBmYWlsZWRcIi5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRTdXBlcnN0cnVjdCh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcil9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVXNlIGluIHRoZSBkZWZhdWx0IGNhc2Ugb2YgYSBzd2l0Y2ggdGhhdCB5b3Ugd2FudCB0byBiZSBmdWxseSBleGhhdXN0aXZlLlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiBmb3JjZXMgdGhlIGNvbXBpbGVyIHRvIGVuZm9yY2UgZXhoYXVzdGl2aXR5IGR1cmluZ1xuICogY29tcGlsZS10aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG51bWJlciA9IDE7XG4gKiBzd2l0Y2ggKG51bWJlcikge1xuICogICBjYXNlIDA6XG4gKiAgICAgLi4uXG4gKiAgIGNhc2UgMTpcbiAqICAgICAuLi5cbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3NlcnRFeGhhdXN0aXZlKHNuYXBQcmVmaXgpO1xuICogfVxuICogYGBgXG4gKiBAcGFyYW0gX29iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHN3aXRjaCBpcyBiZWluZyBvcGVyYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.mjs":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areUint8ArraysEqual: () => (/* binding */ areUint8ArraysEqual),\n/* harmony export */   assertIsBytes: () => (/* binding */ assertIsBytes),\n/* harmony export */   base64ToBytes: () => (/* binding */ base64ToBytes),\n/* harmony export */   bigIntToBytes: () => (/* binding */ bigIntToBytes),\n/* harmony export */   bytesToBase64: () => (/* binding */ bytesToBase64),\n/* harmony export */   bytesToBigInt: () => (/* binding */ bytesToBigInt),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumber: () => (/* binding */ bytesToNumber),\n/* harmony export */   bytesToSignedBigInt: () => (/* binding */ bytesToSignedBigInt),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytes: () => (/* binding */ numberToBytes),\n/* harmony export */   signedBigIntToBytes: () => (/* binding */ signedBigIntToBytes),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   valueToBytes: () => (/* binding */ valueToBytes)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/base */ \"(ssr)/../../node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _assert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.mjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.mjs\");\n/* harmony import */ var _hex_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hex.mjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.mjs\");\n\n\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return () => {\n        if (lookupTable.length === 0) {\n            for (let i = 0; i < 256; i++) {\n                lookupTable.push(i.toString(16).padStart(2, '0'));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return '0x';\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0,_hex_mjs__WEBPACK_IMPORTED_MODULE_1__.add0x)(hexadecimal.join(''));\n}\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes) {\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n    return Number(bigint);\n}\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return _scure_base__WEBPACK_IMPORTED_MODULE_2__.base64.encode(bytes);\n}\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n    // \"0x\" is often used as empty byte array.\n    if (value?.toLowerCase?.() === '0x') {\n        return new Uint8Array();\n    }\n    (0,_hex_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0,_hex_mjs__WEBPACK_IMPORTED_MODULE_1__.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 -\n            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        const n2 = c2 -\n            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */\n    const mask = value >> BigInt(31);\n    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n    /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value === 'number', 'Value must be a number.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value === 'string', 'Value must be a string.');\n    return new TextEncoder().encode(value);\n}\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction base64ToBytes(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof value === 'string', 'Value must be a string.');\n    return _scure_base__WEBPACK_IMPORTED_MODULE_2__.base64.decode(value);\n}\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n    if (typeof value === 'bigint') {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === 'number') {\n        return numberToBytes(value);\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('0x')) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for (let i = 0; i < values.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n/**\n * Compare two Uint8Arrays using a constant-time style loop to reduce timing\n * side-channels when comparing sensitive data (e.g., mnemonic bytes, keys,\n * authentication tags). Does not early-return on the first difference:\n * work done depends only on the input lengths, so byte content does not affect timing.\n *\n * When to use:\n * - Use for secret or security-sensitive byte comparisons to avoid content-based timing leaks.\n * - Prefer when inputs are fixed-length (or validated to equal length) at the API boundary.\n *\n * @param a - The first Uint8Array to compare.\n * @param b - The second Uint8Array to compare.\n * @returns Whether the Uint8Arrays are equal.\n */\nfunction areUint8ArraysEqual(a, b) {\n    // eslint-disable-next-line no-bitwise\n    let diff = a.byteLength ^ b.byteLength;\n    const len = Math.max(a.byteLength, b.byteLength);\n    for (let i = 0; i < len; i++) {\n        const aByte = a[i] ?? 0;\n        const bByte = b[i] ?? 0;\n        // eslint-disable-next-line no-bitwise\n        diff |= aByte ^ bByte;\n    }\n    return diff === 0;\n}\n//# sourceMappingURL=bytes.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQztBQUN5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLCtDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkRBQWlCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVE7QUFDbEMsaUZBQWlGLGNBQWM7QUFDL0Y7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVixJQUFJLG1EQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVixJQUFJLG1EQUFNO0FBQ1YsSUFBSSxtREFBTTtBQUNWLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVixJQUFJLG1EQUFNO0FBQ1YsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVixXQUFXLCtDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQixJQUFJLG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCLFFBQVEsaUJBQWlCO0FBQ3RELDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRCxJQUFJLGtCQUFrQixvQkFBb0IsMEJBQTBCO0FBQ3BFO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRCxpQkFBaUIsZUFBZTtBQUNoQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG15LXNjb3BlL2Fybi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1ldGFtYXNrK3V0aWxzQDExLjguMS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMubWpzP2Q1ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQubWpzXCI7XG5pbXBvcnQgeyBhZGQweCwgYXNzZXJ0SXNIZXhTdHJpbmcsIHJlbW92ZTB4IH0gZnJvbSBcIi4vaGV4Lm1qc1wiO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICAgIGFzc2VydChpc0J5dGVzKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzKCk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGhleGFkZWNpbWFsW2ldID0gbG9va3VwVGFibGVbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gYWRkMHgoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb051bWJlcn0uXG4gKiBUbyBjb252ZXJ0IGEgdHdvJ3MgY29tcGxlbWVudCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLCB1c2VcbiAqIHtAbGluayBieXRlc1RvU2lnbmVkQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBzaWduZWQgYGJpZ2ludGAuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBieXRlcyBhcmVcbiAqIGVuY29kZWQgaW4gdHdvJ3MgY29tcGxlbWVudC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGFuIHVuc2lnbmVkIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHNpZ25lZCBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBzaWduZWQgYGJpZ2ludGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICBhc3NlcnQoYmlnaW50IDw9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksICdOdW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJ5dGVzVG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdpbnQpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0Jhc2U2NChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC4gVGhlIHN0cmluZyBjYW4gb3B0aW9uYWxseSBiZVxuICogcHJlZml4ZWQgd2l0aCBgMHhgLiBJdCBhY2NlcHRzIGV2ZW4gYW5kIG9kZCBsZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgXCIweFwiLCBhbiBlbXB0eSBgVWludDhBcnJheWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICh2YWx1ZT8udG9Mb3dlckNhc2U/LigpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBgMHhgIHByZWZpeCBpZiBpdCBleGlzdHMsIGFuZCBwYWQgdGhlIHN0cmluZyB0byBoYXZlIGFuIGV2ZW5cbiAgICAvLyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gcmVtb3ZlMHgodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub3JtYWxpemVkVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIG5vdCB0aGUgcHJldHRpZXN0IHdheSB0byBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXlgLCBpdCBpcyBhIGxvdCBmYXN0ZXIgdGhhbiB1c2luZyBgcGFyc2VJbnRgIHRvIGNvbnZlcnQgZWFjaFxuICAgICAgICAvLyBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0IGMxID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIpO1xuICAgICAgICBjb25zdCBjMiA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gICAgICAgIGNvbnN0IG4xID0gYzEgLVxuICAgICAgICAgICAgKGMxIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBjb25zdCBuMiA9IGMyIC1cbiAgICAgICAgICAgIChjMiA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBgYmlnaW50YCBpcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiaWdpbnQgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaWdJbnRUb0J5dGVzKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgIGFzc2VydCh2YWx1ZSA+PSBCaWdJbnQoMCksICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgYXNzZXJ0KGJ5dGVzID4gMCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IG1hc2sgPSB2YWx1ZSA+PiBCaWdJbnQoMzEpO1xuICAgIHJldHVybiAhKCgofnZhbHVlICYgbWFzaykgKyAodmFsdWUgJiB+bWFzaykpID4+IEJpZ0ludChieXRlcyAqIDggKyB+MCkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGlzIHVzZXMgdHdvJ3MgY29tcGxlbWVudFxuICogZW5jb2RpbmcgdG8gcmVwcmVzZW50IG5lZ2F0aXZlIG51bWJlcnMuXG4gKlxuICogVG8gY29udmVydCBhbiB1bnNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYFVpbnQ4QXJyYXlgLiBJZiB0aGUgbnVtYmVyXG4gKiBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoLFxuICogYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZEJpZ0ludFRvQnl0ZXModmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgYXNzZXJ0KHR5cGVvZiBieXRlTGVuZ3RoID09PSAnbnVtYmVyJywgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPiAwLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICBhc3NlcnQoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbi8qKlxuICogQ29udmVydCBhIGBudW1iZXJgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICBhc3NlcnQodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgIGFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG4vKipcbiAqIENvbnZlcnQgYSBgc3RyaW5nYCB0byBhIFVURi04IGVuY29kZWQgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIHJldHVybiBiYXNlNjQuZGVjb2RlKHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVUb0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZSBtdWx0aXBsZSBieXRlLWxpa2UgdmFsdWVzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWVzXG4gKiBjYW4gYmUgYFVpbnQ4QXJyYXlgLCBgYmlnaW50YCwgYG51bWJlcmAsIG9yIGBzdHJpbmdgLiBUaGlzIHVzZXNcbiAqIHtAbGluayB2YWx1ZVRvQnl0ZXN9IHVuZGVyIHRoZSBob29kIHRvIGNvbnZlcnQgZWFjaCB2YWx1ZSB0byBieXRlcy4gUmVmZXIgdG9cbiAqIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgICAvLyBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggTm9kZS5qcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgYnl0ZXMgYXJlXG4gICAgLy8gYSBCdWZmZXIuIElmIHNvLCB3ZSBuZWVkIHRvIHNsaWNlIHRoZSBidWZmZXIgdG8gZ2V0IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbn1cbi8qKlxuICogQ29tcGFyZSB0d28gVWludDhBcnJheXMgdXNpbmcgYSBjb25zdGFudC10aW1lIHN0eWxlIGxvb3AgdG8gcmVkdWNlIHRpbWluZ1xuICogc2lkZS1jaGFubmVscyB3aGVuIGNvbXBhcmluZyBzZW5zaXRpdmUgZGF0YSAoZS5nLiwgbW5lbW9uaWMgYnl0ZXMsIGtleXMsXG4gKiBhdXRoZW50aWNhdGlvbiB0YWdzKS4gRG9lcyBub3QgZWFybHktcmV0dXJuIG9uIHRoZSBmaXJzdCBkaWZmZXJlbmNlOlxuICogd29yayBkb25lIGRlcGVuZHMgb25seSBvbiB0aGUgaW5wdXQgbGVuZ3Rocywgc28gYnl0ZSBjb250ZW50IGRvZXMgbm90IGFmZmVjdCB0aW1pbmcuXG4gKlxuICogV2hlbiB0byB1c2U6XG4gKiAtIFVzZSBmb3Igc2VjcmV0IG9yIHNlY3VyaXR5LXNlbnNpdGl2ZSBieXRlIGNvbXBhcmlzb25zIHRvIGF2b2lkIGNvbnRlbnQtYmFzZWQgdGltaW5nIGxlYWtzLlxuICogLSBQcmVmZXIgd2hlbiBpbnB1dHMgYXJlIGZpeGVkLWxlbmd0aCAob3IgdmFsaWRhdGVkIHRvIGVxdWFsIGxlbmd0aCkgYXQgdGhlIEFQSSBib3VuZGFyeS5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBVaW50OEFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiAtIFRoZSBzZWNvbmQgVWludDhBcnJheSB0byBjb21wYXJlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgVWludDhBcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlVWludDhBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBsZXQgZGlmZiA9IGEuYnl0ZUxlbmd0aCBeIGIuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1heChhLmJ5dGVMZW5ndGgsIGIuYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBhQnl0ZSA9IGFbaV0gPz8gMDtcbiAgICAgICAgY29uc3QgYkJ5dGUgPSBiW2ldID8/IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIGRpZmYgfD0gYUJ5dGUgXiBiQnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/bytes.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.mjs":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isErrorWithCode: () => (/* binding */ isErrorWithCode),\n/* harmony export */   isErrorWithMessage: () => (/* binding */ isErrorWithMessage),\n/* harmony export */   isErrorWithStack: () => (/* binding */ isErrorWithStack),\n/* harmony export */   wrapError: () => (/* binding */ wrapError)\n/* harmony export */ });\n/* harmony import */ var pony_cause__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pony-cause */ \"(ssr)/../../node_modules/.pnpm/pony-cause@2.1.11/node_modules/pony-cause/index.mjs\");\n/* harmony import */ var _misc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.mjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.mjs\");\n\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0,_misc_mjs__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause__WEBPACK_IMPORTED_MODULE_0__.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\n//# sourceMappingURL=errors.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Vycm9ycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0QztBQUNhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtREFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFjLFlBQVksc0JBQXNCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixJQUFJLFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMubWpzP2I3MzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JXaXRoQ2F1c2UgfSBmcm9tIFwicG9ueS1jYXVzZVwiO1xuaW1wb3J0IHsgaXNOdWxsT3JVbmRlZmluZWQsIGlzT2JqZWN0IH0gZnJvbSBcIi4vbWlzYy5tanNcIjtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKiBGb3IgZXJyb3JzIGdlbmVyYXRlZCB2aWEgYGZzLnByb21pc2VzYCwgYGVycm9yIGluc3RhbmNlb2YgRXJyb3JgIHdvbid0IHdvcmssXG4gKiBzbyB3ZSBoYXZlIHRvIGNvbWUgdXAgd2l0aCBhbm90aGVyIHdheSBvZiB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRXJyb3InKSk7XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBjb2RlYCBwcm9wZXJ0eSBzdWNoIGFzIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgTm9kZSB0aHJvd3MgZm9yIGZpbGVzeXN0ZW1cbiAqIG9wZXJhdGlvbnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgbWVzc2FnZWAgcHJvcGVydHksIHN1Y2ggYXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcldpdGhTdGFjayhlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdzdGFjaycgaW4gZXJyb3I7XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBpZiAoaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbn1cbi8qKlxuICogQnVpbGRzIGEgbmV3IGVycm9yIG9iamVjdCwgbGlua2luZyBpdCB0byB0aGUgb3JpZ2luYWwgZXJyb3IgdmlhIHRoZSBgY2F1c2VgXG4gKiBwcm9wZXJ0eSBpZiBpdCBpcyBhbiBFcnJvci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB0byByZWZyYW1lIGVycm9yIG1lc3NhZ2VzIGluIGdlbmVyYWwsIGJ1dCBpc1xuICogX2NyaXRpY2FsXyB3aGVuIGludGVyYWN0aW5nIHdpdGggYW55IG9mIE5vZGUncyBmaWxlc3lzdGVtIGZ1bmN0aW9ucyBhc1xuICogcHJvdmlkZWQgdmlhIGBmcy5wcm9taXNlc2AsIGJlY2F1c2UgdGhlc2UgZG8gbm90IHByb2R1Y2Ugc3RhY2sgdHJhY2VzIGluIHRoZVxuICogY2FzZSBvZiBhbiBJL08gZXJyb3IgKHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMDk0ND4pLlxuICpcbiAqIEBwYXJhbSBvcmlnaW5hbEVycm9yIC0gVGhlIGVycm9yIHRvIGJlIHdyYXBwZWQgKHNvbWV0aGluZyB0aHJvd2FibGUpLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZGVzaXJlZCBtZXNzYWdlIG9mIHRoZSBuZXcgZXJyb3IuXG4gKiBAcmV0dXJucyBBIG5ldyBlcnJvciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcldpdGhDYXVzZShtZXNzYWdlLCB7IGNhdXNlOiBvcmlnaW5hbEVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Vycm9yV2l0aENvZGUob3JpZ2luYWxFcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBvcmlnaW5hbEVycm9yLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYCR7U3RyaW5nKG9yaWdpbmFsRXJyb3IpfTogJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhvcmlnaW5hbEVycm9yKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/errors.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.mjs":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HexAddressStruct: () => (/* binding */ HexAddressStruct),\n/* harmony export */   HexChecksumAddressStruct: () => (/* binding */ HexChecksumAddressStruct),\n/* harmony export */   HexStruct: () => (/* binding */ HexStruct),\n/* harmony export */   StrictHexStruct: () => (/* binding */ StrictHexStruct),\n/* harmony export */   add0x: () => (/* binding */ add0x),\n/* harmony export */   assertIsHexString: () => (/* binding */ assertIsHexString),\n/* harmony export */   assertIsStrictHexString: () => (/* binding */ assertIsStrictHexString),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getChecksumAddressUnmemoized: () => (/* binding */ getChecksumAddressUnmemoized),\n/* harmony export */   isHexAddress: () => (/* binding */ isHexAddress),\n/* harmony export */   isHexChecksumAddress: () => (/* binding */ isHexChecksumAddress),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   isStrictHexString: () => (/* binding */ isStrictHexString),\n/* harmony export */   isValidChecksumAddress: () => (/* binding */ isValidChecksumAddress),\n/* harmony export */   isValidChecksumAddressUnmemoized: () => (/* binding */ isValidChecksumAddressUnmemoized),\n/* harmony export */   isValidHexAddress: () => (/* binding */ isValidHexAddress),\n/* harmony export */   isValidHexAddressUnmemoized: () => (/* binding */ isValidHexAddressUnmemoized),\n/* harmony export */   remove0x: () => (/* binding */ remove0x)\n/* harmony export */ });\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/structs/refinements.mjs\");\n/* harmony import */ var _metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/../../node_modules/.pnpm/@metamask+superstruct@3.2.1/node_modules/@metamask/superstruct/dist/structs/types.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"(ssr)/../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js\");\n/* harmony import */ var _assert_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert.mjs */ \"(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/assert.mjs\");\n\n\n\nconst { memoize } = lodash__WEBPACK_IMPORTED_MODULE_0__;\n\n// Use native regexes instead of superstruct for maximum performance.\n// Pre-compiled regex for maximum performance - avoids recompilation on each call\nconst HEX_REGEX = /^(?:0x)?[0-9a-f]+$/iu;\nconst STRICT_HEX_REGEX = /^0x[0-9a-f]+$/iu;\nconst HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/u;\nconst HEX_CHECKSUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/u;\nconst HexStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.pattern)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.string)(), HEX_REGEX);\nconst StrictHexStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.pattern)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.string)(), STRICT_HEX_REGEX);\nconst HexAddressStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.pattern)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.string)(), HEX_ADDRESS_REGEX);\nconst HexChecksumAddressStruct = (0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_1__.pattern)((0,_metamask_superstruct__WEBPACK_IMPORTED_MODULE_2__.string)(), HEX_CHECKSUM_ADDRESS_REGEX);\nconst isString = (value) => typeof value === 'string';\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n    return isString(value) && HEX_REGEX.test(value);\n}\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n    return isString(value) && STRICT_HEX_REGEX.test(value);\n}\n/**\n * Check if a string is a valid hex address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex address.\n */\nfunction isHexAddress(value) {\n    return isString(value) && HEX_ADDRESS_REGEX.test(value);\n}\n/**\n * Check if a string is a valid hex checksum address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex checksum address.\n */\nfunction isHexChecksumAddress(value) {\n    return isString(value) && HEX_CHECKSUM_ADDRESS_REGEX.test(value);\n}\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_3__.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_3__.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This is the unmemoized version, primarily used for testing.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nfunction getChecksumAddressUnmemoized(hexAddress) {\n    (0,_assert_mjs__WEBPACK_IMPORTED_MODULE_3__.assert)(isHexChecksumAddress(hexAddress), 'Invalid hex address.');\n    const address = remove0x(hexAddress).toLowerCase();\n    const hashBytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_4__.keccak_256)(address);\n    const { length } = address;\n    const result = new Array(length); // Pre-allocate array\n    for (let i = 0; i < length; i++) {\n        /* eslint-disable no-bitwise */\n        const byteIndex = i >> 1; // Faster than Math.floor(i / 2)\n        const nibbleIndex = i & 1; // Faster than i % 2\n        const byte = hashBytes[byteIndex];\n        const nibble = nibbleIndex === 0 ? byte >> 4 : byte & 0x0f;\n        /* eslint-enable no-bitwise */\n        result[i] = nibble >= 8 ? address[i].toUpperCase() : address[i];\n    }\n    return `0x${result.join('')}`;\n}\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This function is memoized for performance.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nconst getChecksumAddress = memoize(getChecksumAddressUnmemoized);\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nfunction isValidChecksumAddressUnmemoized(possibleChecksum) {\n    if (!isHexChecksumAddress(possibleChecksum)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nconst isValidChecksumAddress = memoize(isValidChecksumAddressUnmemoized);\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nfunction isValidHexAddressUnmemoized(possibleAddress) {\n    return (isHexAddress(possibleAddress) || isValidChecksumAddress(possibleAddress));\n}\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nconst isValidHexAddress = memoize(isValidHexAddressUnmemoized);\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\n//# sourceMappingURL=hex.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDSztBQUNoQztBQUM3QixRQUFRLFVBQVUsRUFBRSxtQ0FBTztBQUNXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUMsbURBQW1ELEdBQUc7QUFDL0Msa0JBQWtCLDhEQUFPLENBQUMsNkRBQU07QUFDaEMsd0JBQXdCLDhEQUFPLENBQUMsNkRBQU07QUFDdEMseUJBQXlCLDhEQUFPLENBQUMsNkRBQU07QUFDdkMsaUNBQWlDLDhEQUFPLENBQUMsNkRBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksbURBQU07QUFDVjtBQUNBLHNCQUFzQiw4REFBUztBQUMvQixZQUFZLFNBQVM7QUFDckIsc0NBQXNDO0FBQ3RDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0Esa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXgubWpzP2Q5ZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGF0dGVybiwgc3RyaW5nIH0gZnJvbSBcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiO1xuaW1wb3J0IHsga2VjY2FrXzI1NiBhcyBrZWNjYWsyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG5pbXBvcnQgJGxvZGFzaCBmcm9tIFwibG9kYXNoXCI7XG5jb25zdCB7IG1lbW9pemUgfSA9ICRsb2Rhc2g7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQubWpzXCI7XG4vLyBVc2UgbmF0aXZlIHJlZ2V4ZXMgaW5zdGVhZCBvZiBzdXBlcnN0cnVjdCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS5cbi8vIFByZS1jb21waWxlZCByZWdleCBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZSAtIGF2b2lkcyByZWNvbXBpbGF0aW9uIG9uIGVhY2ggY2FsbFxuY29uc3QgSEVYX1JFR0VYID0gL14oPzoweCk/WzAtOWEtZl0rJC9pdTtcbmNvbnN0IFNUUklDVF9IRVhfUkVHRVggPSAvXjB4WzAtOWEtZl0rJC9pdTtcbmNvbnN0IEhFWF9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZdezQwfSQvdTtcbmNvbnN0IEhFWF9DSEVDS1NVTV9BRERSRVNTX1JFR0VYID0gL14weFswLTlhLWZBLUZdezQwfSQvdTtcbmV4cG9ydCBjb25zdCBIZXhTdHJ1Y3QgPSBwYXR0ZXJuKHN0cmluZygpLCBIRVhfUkVHRVgpO1xuZXhwb3J0IGNvbnN0IFN0cmljdEhleFN0cnVjdCA9IHBhdHRlcm4oc3RyaW5nKCksIFNUUklDVF9IRVhfUkVHRVgpO1xuZXhwb3J0IGNvbnN0IEhleEFkZHJlc3NTdHJ1Y3QgPSBwYXR0ZXJuKHN0cmluZygpLCBIRVhfQUREUkVTU19SRUdFWCk7XG5leHBvcnQgY29uc3QgSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gcGF0dGVybihzdHJpbmcoKSwgSEVYX0NIRUNLU1VNX0FERFJFU1NfUkVHRVgpO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgSEVYX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBTdHJpY3RseSBjaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0XG4gKiBzdGFydCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiBTVFJJQ1RfSEVYX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIEhFWF9BRERSRVNTX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hleENoZWNrc3VtQWRkcmVzcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgSEVYX0NIRUNLU1VNX0FERFJFU1NfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIGFzc2VydChpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgYXNzZXJ0KGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBpcyB0aGUgdW5tZW1vaXplZCB2ZXJzaW9uLCBwcmltYXJpbHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gaGV4QWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBlbmNvZGVkIGFjY29yZGluZyB0byBFUkMtNTUuXG4gKiBAc2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQoaGV4QWRkcmVzcykge1xuICAgIGFzc2VydChpc0hleENoZWNrc3VtQWRkcmVzcyhoZXhBZGRyZXNzKSwgJ0ludmFsaWQgaGV4IGFkZHJlc3MuJyk7XG4gICAgY29uc3QgYWRkcmVzcyA9IHJlbW92ZTB4KGhleEFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaEJ5dGVzID0ga2VjY2FrMjU2KGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhZGRyZXNzO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpOyAvLyBQcmUtYWxsb2NhdGUgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICAgICAgY29uc3QgYnl0ZUluZGV4ID0gaSA+PiAxOyAvLyBGYXN0ZXIgdGhhbiBNYXRoLmZsb29yKGkgLyAyKVxuICAgICAgICBjb25zdCBuaWJibGVJbmRleCA9IGkgJiAxOyAvLyBGYXN0ZXIgdGhhbiBpICUgMlxuICAgICAgICBjb25zdCBieXRlID0gaGFzaEJ5dGVzW2J5dGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5pYmJsZSA9IG5pYmJsZUluZGV4ID09PSAwID8gYnl0ZSA+PiA0IDogYnl0ZSAmIDB4MGY7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xuICAgICAgICByZXN1bHRbaV0gPSBuaWJibGUgPj0gOCA/IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKSA6IGFkZHJlc3NbaV07XG4gICAgfVxuICAgIHJldHVybiBgMHgke3Jlc3VsdC5qb2luKCcnKX1gO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBwYXNzZWQgaGV4IHN0cmluZyBhcyBhbiBFUkMtNTUgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBtZW1vaXplZCBmb3IgcGVyZm9ybWFuY2UuXG4gKlxuICogQHBhcmFtIGhleEFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3MgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGFkZHJlc3MgZW5jb2RlZCBhY2NvcmRpbmcgdG8gRVJDLTU1LlxuICogQHNlZSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDaGVja3N1bUFkZHJlc3MgPSBtZW1vaXplKGdldENoZWNrc3VtQWRkcmVzc1VubWVtb2l6ZWQpO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgaGV4IHN0cmluZyBpcyBhIHZhbGlkIEVSQy01NSBtaXhlZC1jYXNlXG4gKiBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUNoZWNrc3VtIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzVW5tZW1vaXplZChwb3NzaWJsZUNoZWNrc3VtKSB7XG4gICAgaWYgKCFpc0hleENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUNoZWNrc3VtKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIHBhc3NlZCBoZXggc3RyaW5nIGlzIGEgdmFsaWQgRVJDLTU1IG1peGVkLWNhc2VcbiAqIGNoZWNrc3VtIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQ2hlY2tzdW0gLSBUaGUgaGV4IGFkZHJlc3MgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgY2hlY2tzdW0gYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBtZW1vaXplKGlzVmFsaWRDaGVja3N1bUFkZHJlc3NVbm1lbW9pemVkKTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3NVbm1lbW9pemVkKHBvc3NpYmxlQWRkcmVzcykge1xuICAgIHJldHVybiAoaXNIZXhBZGRyZXNzKHBvc3NpYmxlQWRkcmVzcykgfHwgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpKTtcbn1cbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEhleEFkZHJlc3MgPSBtZW1vaXplKGlzVmFsaWRIZXhBZGRyZXNzVW5tZW1vaXplZCk7XG4vKipcbiAqIEFkZCB0aGUgYDB4YC1wcmVmaXggdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgYWxyZWFkeSBoYXMgdGhlXG4gKiBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYWRkIHRoZSBwcmVmaXggdG8uXG4gKiBAcmV0dXJucyBUaGUgcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/hex.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.mjs":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ESCAPE_CHARACTERS_REGEXP: () => (/* binding */ ESCAPE_CHARACTERS_REGEXP),\n/* harmony export */   JsonSize: () => (/* binding */ JsonSize),\n/* harmony export */   calculateNumberSize: () => (/* binding */ calculateNumberSize),\n/* harmony export */   calculateStringSize: () => (/* binding */ calculateStringSize),\n/* harmony export */   getKnownPropertyNames: () => (/* binding */ getKnownPropertyNames),\n/* harmony export */   hasProperty: () => (/* binding */ hasProperty),\n/* harmony export */   isASCII: () => (/* binding */ isASCII),\n/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray),\n/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)\n/* harmony export */ });\n//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nconst ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXRhbWFzayt1dGlsc0AxMS44LjEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUNBQXVDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbXktc2NvcGUvYXJuLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWV0YW1hc2srdXRpbHNAMTEuOC4xL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9taXNjLm1qcz80MmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBUeXBlc1xuLy9cbi8vXG4vLyBUeXBlIEd1YXJkc1xuLy9cbi8qKlxuICogQSB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgRWxlbWVudCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIHtAbGluayBSdW50aW1lT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaGFzIGEgcnVudGltZSB0eXBlIG9mIGBvYmplY3RgIGFuZCBpc1xuICogbmVpdGhlciBgbnVsbGAgbm9yIGFuIGBBcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtub3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbn1cbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG5leHBvcnQgdmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBKc29uU2l6ZSB8fCAoSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgY29uc3QgRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKHZhbHVlLm1hdGNoKEVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHNpemUgb2YgYSBudW1iZXIgb2Z0ZXIgSlNPTiBzZXJpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIG51bWJlciBpbiBKU09OLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@metamask+utils@11.8.1/node_modules/@metamask/utils/dist/misc.mjs\n");

/***/ })

};
;